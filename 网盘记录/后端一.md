## Spring Boot项目搭建

### 项目介绍

网盘项目一直以来都是一个比较热门的话题，可能每个人都希望能够拥有自己的网盘，那么本实验课程，就手把手教大家如何搭建一个网盘项目，另外如果你想要快速提高自己的开发水平，那么这个项目就非常适合你。

本课程我们将使用 Spring Boot 和 Vue 这两个热门开源框架来进行开发。在学习完本次课程之后，你不仅能够达到熟练使用 Spring Boot 和 Vue ，而且将会具备独立开发一个完整项目的能力，包括前端、后台、运维、数据库建模、系统设计等。因此，项目讲解最终目的并不是简单的教大家完成如何开发网盘，而是要教会大家学会如何思考问题，如何设计才能提高系统的可扩展性，面对一个新需求如何进行分析、建模。往往一个好的底层设计，不管需求如何改变，都是能满足系统要求，而一旦设计出了问题，那么随着后面需求复杂度的提升，其结果无外乎是代码冗余越来越多，最终推翻重来。

项目的开发模式为前后端分离模式，前后台分离的好处就是我们可以对前后台独立开发和部署，这种模式是以后发展的趋势，在前面实验课程主要以 Spring Boot 为重点展开讲解，后面实验课程教大家用 Vue-Cli3 来制作前台页面并请求后台接口。接下来我们就会从最基本的概念讲起，教大家一步一步的去完成项目的开发。

### Spring Boot 基本概念介绍

Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。也就是说 Spring Boot 集成了很多第三方库，并且都给了一套默认的配置，这样我们在使用 Spring Boot 时仅仅只需要很少的配置即可。Spring Boot 的迭代升级是很快的，到目前为止最新的发布版本是 2.4.1，本课程也将会基于 2.4.1 版本展开讲解。

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/c4ed98dcf8e2b87e878d0c6752f46e9a-0)

#### SpringBoot 所具备的特征

1. 可以创建独立的 Spring 应用程序，并且基于其 Maven 或 Gradle 插件，可以创建可执行的 JAR 和 WAR。
2. 内嵌 Tomcat 或 Jetty 等 Servlet 容器。
3. 提供自动配置的“starter”项目对象模型（POMS）以简化 Maven 配置。
4. 尽可能自动配置 Spring 容器。
5. 提供准备好的特性，如指标、健康检查和外部化配置。
6. 不需要 XML 配置。

### 修改 pom.xml



在项目的根路径下有一个名为 `pom.xml` 的文件，pom 文件是 maven 构建的根本，它约定了项目构建所需要的相关信息和依赖，打开 `pom.xml` 文件，初始化如下内容：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.shiyanlou.file</groupId>
    <artifactId>qiwen-file</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>jar</packaging>

</project>
```

### 添加 Spring Boot 依赖



#### 增加父 pom 依赖

在 `pom.xml` 中的 `project` 节点下，增加如下依赖。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.4.1</version>
</parent>
```

`spring-boot-starter-parent` 是 Spring Boot 项目的父 pom，它里面定义了 Spring Boot 所使用的依赖库版本等信息，但它本身并没有任何依赖。

#### 项目依赖

在 `pom.xml` 中的 `project` 节点下，继续增加如下依赖。

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

上面这段 xml 脚本增加了两个依赖，其中：

`spring-boot-starter-web` 依赖项是 Spring Boot 的核心，引入该依赖之后 Spring Boot 将会使用 SpringMVC 构建一个 Web 应用程序，且使用 Tomcat 作为默认的嵌入式容器。

`spring-boot-starter-test` 包含了很多测试依赖项的类库，比如 JUnit Jupiter，Hamcrest 和 Mockito，引入这个依赖之后就可以直接进行单元测试类的编写。

上面这两个依赖项是 Spring Boot 最基本的依赖，可以看到在引用的时候并没有版本号定义，其实 Spring Boot 的父 pom 的三方件管理库已经为我们定义好了，这里我们只需要直接使用即可。一般来说，我们在构建项目的时候，也应该这样做，将所有引用的第三方 jar 版本统一定义到最上层的父 pom，做到统一管理和配置，比如 Spring Boot 这种，我们在后期升级 Spring Boot 版本时，只需要更改 parent 这一处引入版本，整个项目的所有引用依赖都会被升级 。

### 创建 Spring Boot 启动类



#### 创建包

在 `src/main/java` 下，创建一个包，一般是根据项目命名，这里我创建一个名为 `com.shiyanlou.file` 的包，以后所有的代码就都放到这个包下面。

#### 创建启动类

在 `com.shiyanlou.file` 包下创建一个名为 Application 的 Java 类，创建完成的示例图如下：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/503ae3588db55a9db0ab0d01de8572ef-0)

#### 编写启动类内容

在 `Application.java` 的类中添加内容如下：

```java
package com.shiyanlou.file;

import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
```

- `@SpringBootApplication` 是 Spring Boot 的核心注解，顾名思义，它用来声明该项目是一个 Spring Boot 应用。
- `main` 方法，Java 应用程序一般使用 main 方法来作为整个程序的入口，Spring Boot 也遵循了这一标准，我们的主方法通过调用 run 来委托 Spring Boot 的 SpringApplication 类。SpringApplication 引导我们的应用程序，启动 Spring，而 Spring 又启动自动配置的 Tomcat web 服务器。我们需要传递 `Application.class` 作为 run 方法的参数来告诉 SpringApplication 哪个是主要的 Spring 组件。args 数组也可以接收任何命令行参数。

### 配置数据库连接



#### 添加依赖

打开 `pom.xml` 文件，在 `dependencies` 节点下添加如下依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```

在 `src/main/resources` 目录下创建 `application.properties` 文件，该文件是 Spring Boot 默认读取的配置文件，创建完成之后打开 `application.properties` 文件，添加 MySQL 连接的相关配置，具体代码如下：

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/file
spring.datasource.username=root
spring.datasource.password=
```

其中：

- `spring.datasource.url` 配置了数据库连接的 url，Spring Boot 会根据它的属性值来判断数据源并进行连接；
- `spring.datasource.username` 指定数据库的用户名；
- `spring.datasource.password` 配置数据库的密码。

### 配置日志



因为 Spring Boot 内部已经集成了 Logback 日志模块，所以，我们只在 `application.properties` 配置文件中添加 log 日志的相关信息即可。

#### 添加配置

```properties
# 配置日志保存路径
logging.file.name=/home/project/log/web.log
# 配置日志级别
logging.level.root=info
```

### 需求分析



在数据库建模之前，首先要做的就是需求分析，目的是对将要设计的系统有一个足够的认识，接下来我将带领大家来分析一个网盘系统，并一步步去实现它。

#### 文件的概念

网盘系统主要是对文件进行管理，因此我们需要对文件有一个清晰的认识，我这里列出几个比较重要的点：

1. 文件分为普通文件和目录文件。
2. 普通文件是真实存在的，保存在磁盘空间的一个二进制文件，因此它具有真实的文件路径和大小。
3. 目录文件是虚拟的，它存在的目的是对普通文件进行分类归档。

#### 文件的物理存储和逻辑存储

在计算机内部，由于文件都是以二进制的形式进行存储的，因此一个文件实际上就是一个二进制文件，占用一定的磁盘空间，这就是文件的**物理存储**。而作为一个网盘项目，我们在界面上展示的文件信息实际上只是在数据库存储的数据信息，包括文件路径，文件大小，文件名等，但是它会通过一个 url 字段指向服务器的一个具体文件，这就是**逻辑存储**。如下图：

![图片描述](后端一.assets/d899bd3dd73c22d90495f2c19f84c67a-0)

### 数据库建模



数据库建模，就是对现实世界进行分析、抽象、并从中找出内在联系，进而确定数据库的结构，这一过程就称为数据库建模。它主要包括两部分内容：

1. 确定最基本的数据结构
2. 对约束建模。

这里我先给出一个简单的需求说明，然后根据这个需求，我们来一步步实现一个完整的数据库建模过程。

#### 需求说明

实现一个网盘项目，然后实现用户登录，登录用户可以对文件进行管理，其中包含以下功能：

1. 文件的上传，删除，列表展示，修改名称
2. 文件的移动，文件的复制

#### 根据需求说明提取实体和属性

从上面需求描述，我们需要从中提取出实体和属性，如下表：

| 实体 | 属性                            |
| ---- | ------------------------------- |
| 文件 | 文件名、扩展名、大小、路径、... |
| 用户 | 用户名、手机号、密码、年龄、... |

上表只是给出了一个示例，你可以根据自己的理解和实际需要对属性进行扩展，当实体和属性提取出来之后，就可以对实体和属性，实体和实体之间的关系进行分析，这个分析过程需要用 E-R 图，下面借助 E-R 图来说明整个分析过程。

### E-R 图



E-R 图也称为实体-联系图（Entity Relationship Diagram），它提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。

在 E-R 图中，分别用矩形、菱形、椭圆形来表示不同的含义，如下表：

| 形状   | 含义             |
| ------ | ---------------- |
| 矩形   | 实体             |
| 菱形   | 实体之间的联系   |
| 椭圆形 | 实体或联系的属性 |

了解了 E-R 图的规则之后，现在我们将上面的文件和用户这两个实体 E-R 图表示出来，如下图：

- 文件

![图片描述](后端一.assets/a254eb024df03523608ac5da27ceaa1e-0)

- 用户

![图片描述](后端一.assets/03ac92c81e68e78ce68f9a0ce09a2f42-0)

### 文件与用户的关系



由于文件是需要用户去进行管理的，因此这里要清楚文件和用户之间的关系，是一对一、一对多、还是多对多，然后在 ER 图中将他们关联起来。

要搞清楚他们之间的关系，首先需要明确下面两个问题：

1. 一个用户能否拥有多个文件
2. 一个文件是否可以被多个用户所拥有

作为一个网盘系统，一个用户肯定是能够拥有多个文件，主要关键在于一个文件是否可以被多个用户所拥有，由于后面我们要实现极速秒传的功能，那么这里就会涉及到，一个文件被多个用户所拥有。

从以上两个问题的分析结果，可以得出用户和文件之间是多对多的关系，因此在 ER 图中，我们可以将文件和用户关联起来，如下图：

![图片描述](后端一.assets/e96a636ce60ee5c8b06cc7131985a754-0)

从上图可以看出，两个实体之间进行关联需要用到菱形，在菱形的两边用 M 进行标识，表示两个实体类之间是多对多的关系。

### 将多对多联系转为一对多联系模型



在数据库设计中，如果两个实体之间是多对多的关系，那么就需要一张中间表进行关联，从而将多对多联系转为一对多联系模型。这个操作是关键点，也是难点，因为之前的两个实体都是直观的，现在就需要抽象出来一个新的实体。

我们将这种中间表起名为用户文件表，它存在的意义就是将文件表和用户表关联起来，如下图：

![图片描述](后端一.assets/87d4eed2c6e530a118aaa9de9deb2f49-0)

到此为止，整个数据库底层的关系模型就已经出来了，在此之前，我们所说的文件还是一个模糊的概念，而到了这一步，整个关系模型跟之前讲物理存储和逻辑存储的图正好能够对应，其中文件就是物理存储，它跟磁盘存储的文件是一一对应的，用户文件属于逻辑存储，用户在前台对文件进行移动复制等操作，其实只是做一些数据库的操作，但是指向文件的 url 没有变动，这就恰恰反向论证了整个设计思路是没有问题的。

根据上图，这里还需要做进一步的解释，我们发现，在整个 E-R 图的演进过程中，本来属于文件的属性，我却把它放到了用户文件这一层，比如文件名，扩展名，是否是目录，其原因是修改文件名和扩展名，是不会影响文件本身的二进制内容，你可以不妨一试，因此我将它放到逻辑存储的用户文件属性中了。另外我们在文件磁盘存储的角度是不存在目录这个概念的，它只是我们在管理层面抽象出来的，因此它也需要提升到用户文件这个实体类中。

### JPA 建表



JPA（Java Persistence API)，中文名 Java 持久层 API，是 Java 持久化规范，简单的理解就是它为 Java 开发者提供了一个对象映射工具，可以使用这个工具，建立一个 Java 数据模型与数据库表结构之间的一种关系，并将 Java 的数据模型映射到数据库并建立数据库表结构，当然它还有众多的优点，在这里我们重点介绍它的使用方法。

#### 引入依赖

向 `pom.xml` 文件中补充如下依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
```

上面这段代码引入了两个依赖：

第一个依赖就是 jpa 的依赖包，第二个依赖是 Lombok 依赖，Lombok 提供了一组有用的注解，用来消除 Java 类中的大量样板代码。仅五个字符（@Data）就可以替换数百行代码从而产生干净，简洁且易于维护的 Java 类。

#### 添加配置文件

打开 `application.proterties` 文件，添加如下内容：

```properties
#jpa 配置
spring.jpa.properties.hibernate.hbm2ddl.auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.show-sql=true
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```

需要注意的是最后一行配置，用来定义命名策略，如果不设置，会使用默认的命名策略，比如建表时，会将有驼峰命名的转换为全小写，并用横线分割如：实体类名：userCommon，映射到表名就是 user-common。

### 创建实体类



打开项目，在 `com.shiyanlou.file` 包下创建一个 `model` 的包，这个包就用来存放我们的实体类对象。

在这个包下，我们需要创建三个 Java 类，用来存放之前设计的实体。接下来我们首先创建一张用户的实体类，并添加 jpa 相关的注解。

#### 用户实体类

新建 `User.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.model;

import lombok.Data;

import javax.persistence.*;

@Data
@Table(name = "user")
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(columnDefinition = "bigint(20) comment '用户id'")
    private Long userId;

    @Column(columnDefinition = "varchar(30) comment '用户名'")
    private String username;

    @Column(columnDefinition = "varchar(35) comment '密码'")
    private String password;

    @Column(columnDefinition = "varchar(15) comment '手机号码'")
    private String telephone;

    @Column(columnDefinition = "varchar(20) comment '盐值'")
    private String salt;

    @Column(columnDefinition = "varchar(30) comment '注册时间'")
    private String registerTime;

}
```

上面是一个用户实体类，里面的用户属性我只列出了登录所需的关键属性，你可以根据自己的需要补充其他用户属性，比如年龄，性别，省市区等。上面涉及到的 jpa 注解，它的含义如下表：

| 注解名称        | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| @Entity         | 表明该类是一个实体类，添加了该注解后，才能被 jpa 扫描到      |
| @Table          | 可以自定义表名                                               |
| @Id             | 用来声明主键                                                 |
| @GeneratedValue | 设置主键生成方式，主要有四种类型，这里我们将 strategy 属性设置为 GenerationType.IDENTITY，表明主键由数据库生成，为自动增长型 |
| @Column         | 可以自定义列名或者定义其他的数据类型                         |

#### 文件实体类

新建 `File.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.model;

import lombok.Data;

import javax.persistence.*;

@Data
@Table(name = "file")
@Entity
public class File {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(columnDefinition="bigint(20) comment '文件id'")
    private Long fileId;

    @Column(columnDefinition="varchar(500) comment '时间戳名称'")
    private String timeStampName;

    @Column(columnDefinition="varchar(500) comment '文件url'")
    private String fileUrl;

    @Column(columnDefinition="bigint(10) comment '文件大小'")
    private Long fileSize;

}
```

#### 用户文件实体类

新建 `UserFile.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.model;

import lombok.Data;

import javax.persistence.*;

@Data
@Table(name = "userfile", uniqueConstraints = {
        @UniqueConstraint(name = "fileindex", columnNames = {"fileName", "filePath", "extendName"})})
@Entity
public class UserFile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(columnDefinition = "bigint(20) comment '用户文件id'")
    private Long userFileId;

    @Column(columnDefinition = "bigint(20) comment '用户id'")
    private Long userId;

    @Column(columnDefinition="bigint(20) comment '文件id'")
    private Long fileId;

    @Column(columnDefinition="varchar(100) comment '文件名'")
    private String fileName;

    @Column(columnDefinition="varchar(500) comment '文件路径'")
    private String filePath;

    @Column(columnDefinition="varchar(100) comment '扩展名'")
    private String extendName;

    @Column(columnDefinition="int(1) comment '是否是目录 0-否, 1-是'")
    private Integer isDir;

    @Column(columnDefinition="varchar(25) comment '上传时间'")
    private String uploadTime;

}
```

### 启动类添加 Mapper 扫描包路径



在 Spring Boot 启动类 `Application.java` 中添加 `@MapperScan` 注解，用来指定要扫描的 Mapper 文件夹：

```java
package com.shiyanlou.file;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;
import org.springframework.web.bind.annotation.*;

@MapperScan("com.shiyanlou.file.mapper")
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
```

### 开发 Mapper 接口类



在上面 `@MapperScan` 注解扫描路径下，创建 Mapper 接口类，Mapper 接口主要是用来生产 Sql 调用接口，供上层调用，一般来说每个实体类都应该对应一个 Mapper 接口，因此下面我将会创建三个 Mapper 接口，并以 UserMapper 接口为例，给出一个使用案例。

在 `com.shiyanlou.file.mapper` 包下创建三个接口，分别为 `FileMapper`，`UserfileMapper` 和 `UserMapper`，如下图：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/00f96d0e9dbfab27060f996c4e251ce8-0)

#### FileMapper 接口

```java
package com.shiyanlou.file.mapper;

public interface FileMapper {

}
```

#### UserfileMapper 接口

```java
package com.shiyanlou.file.mapper;

public interface UserfileMapper {

}
```

#### UserMapper 接口

```java
package com.shiyanlou.file.mapper;

import com.shiyanlou.file.model.User;
import java.util.List;

public interface UserMapper {
    void insertUser(User user);
    List<User> selectUser();
}
```

上面创建的 UserMapper 接口中，新建了两个操作，分别是新增用户和查询，下面来创建它们对应的映射文件。

### 添加映射文件



在 `resources` 目录下新增 `mybatis` 目录，并在该目录下创建配置文件 `mybatis-config.xml` ，该配置文件主要用来指定 MyBatis 基础配置文件和实体类映射文件的地址，你也可以根据自己的习惯进行修改，如下：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>
    <typeAliases>
        <typeAlias alias="Integer" type="java.lang.Integer" />
        <typeAlias alias="Long" type="java.lang.Long" />
        <typeAlias alias="HashMap" type="java.util.HashMap" />
        <typeAlias alias="LinkedHashMap" type="java.util.LinkedHashMap" />
        <typeAlias alias="ArrayList" type="java.util.ArrayList" />
        <typeAlias alias="LinkedList" type="java.util.LinkedList" />
    </typeAliases>
</configuration>
```

继续在 `mybatis` 目录下创建 `mapper` 目录，并创建 xml 格式的文件，其名称与上面创建的 mapper 接口相对应，如下图：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/3dc7f358f6c63d136d227b527c1b64bb-0)

上面 `UserMapper.java` 接口中创建了两个操作，因此这里需要在它对应的 `UserMapper.xml` 中创建其 SQL 实现，初始化内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.shiyanlou.file.mapper.UserMapper">
    <insert id="insertUser" parameterType="com.shiyanlou.file.model.User">
        insert into user (username, password, telephone)
        value (#{username}, #{password}, #{telephone})
    </insert>

    <select id="selectUser" resultType="com.shiyanlou.file.model.User">
        select * from user
    </select>
</mapper>
```

上面这段 xml 脚本中：

- `namespace` 指定了它的 Mapper 接口，因此它的内容就是 Mapper 接口的包名；
- `insert` 标签和 `select` 标签分别对应 Mapper 接口中的插入和查询操作，因此这里的标签 id 与 Mapper 接口的方法名是一致的。

到此为止整个 MyBatis 的代码调用流程就已经实现，接下来我们对代码进行测试。

### Mybatis-plus添加配置



如果我们不设置 MyBatis-Plus 默认的驼峰式编码，在 MyBatis-Plus 则会默认把驼峰式编码映射为下划线格式，比如实体类种属性 userId 映射到数据库字段 user_id, 这种下划线格式的字段会导致代码报错，所以我们需要关闭驼峰命名规则映射，在 `application.properties` 配置文件中添加如下配置：

```properties
mybatis-plus.mapper-locations=classpath:mybatis/mapper/*.xml

mybatis-plus.configuration.map-underscore-to-camel-case=false
```

### 添加注解



在之前已经创建的三个实体类中，需要添加 MyBatis-Plus 相关注解，这里需要用到的注解有两个，分别是 `@TableName` 和 `@TableId`。

#### 注解说明

| 注解                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| @TableName(“表名”)           | 实体类添加，如果不添加，会按照默认规则进行表明的映射，比如 UserTable->user_table |
| @TableId(type = IdType.AUTO) | 用来标注实体类主键                                           |

#### 实体类添加注解

向 `UserFile.java` 文件中添加如下代码：

```java
...
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.TableId;

...
@TableName("userfile")
public class UserFile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @TableId(type = IdType.AUTO)
    @Column(columnDefinition = "bigint(20) comment '用户文件id'")
    private Long userFileId;

    ...
```

向 `User.java` 文件中添加如下代码：

```java
...
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.TableId;

...
@TableName("user")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @TableId(type = IdType.AUTO)
    @Column(columnDefinition = "bigint(20) comment '用户id'")
    private Long userId;

    ...
```

向 `File.java` 文件中添加如下代码：

```java
...
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.TableId;

...
@TableName("file")
public class File {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @TableId(type = IdType.AUTO)
    @Column(columnDefinition="bigint(20) comment '文件id'")
    private Long fileId;

    ...
```

### Mapper 接口继承 BaseMapper



这里我们以 `UserMapper.java` 为例，进行讲解。打开 `UserMapper.java` 并继承 `BaseMapper`，代码如下：

```java
package com.shiyanlou.file.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.shiyanlou.file.model.User;
import java.util.List;

public interface UserMapper extends BaseMapper<User>{
    void insertUser(User user);
    List<User> selectUser();
}
```

### RESTful 基本概念



RESTful 是一种网络应用程序的设计风格和开发方式，给出一种约定的标准，包含 API 接口规范、命名规则、URL、返回值、授权验证等，下面就介绍几种主要的设计规范，当我们在项目编写当中需要尽可能的去遵守。

#### 正确使用 HTTP 请求方法

HTTP 请求有 5 种请求方法，对应 CRUD 操作，通常我们使用 GET 来做查询，POST 做提交。

- GET：读取（Read）
- POST：新建（Create）
- PUT：更新（Update）
- PATCH：更新（Update），通常是部分更新
- DELETE：删除（Delete）

#### url 路径

既然上面 HTTP 请求方法已经为我们指定了请求的动作，那么请求的 url 路径只需要指定好需要请求的资源就可以了，它是名词，而非动词，或者动宾，比如 `/articles` 就是正确的，而下面的 URL 不是名词，所以是错误的：

- `/getArticles`
- `/createNewCar`
- `/deleteAllRedCars`

#### URL 格式

URL 是不区分单数和复数的，通常的做法是当读取一个集合，比如 `GET /articles`，则表示读取所有文章，`GET /articles/3` 则表示读取某一篇文章。

#### 避免 URL 嵌套过深

常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。

```text
GET /authors/12/categories/2
```

这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。更好的做法是，除了第一级，其他级别都用查询字符串表达。

```text
GET /authors/12?categories=2
```

下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。

```text
GET /articles/published
```

查询字符串的写法明显更好。

```text
GET /articles?published=true
```

#### 服务器响应

接口的 API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的 Content-Type 属性要设为 `application/json`。 目前的前后端开发大部分数据的传输格式都是 JSON，因此定义一个统一规范的数据格式有利于前后端的交互与 UI 的展示。

### 定义结果枚举类



一般后台返回给前台的状态可以大致分为两类：成功和失败，但是失败的情况却有很多种，为了能够让前台调用者更加清楚的知道后台报了什么错，这里我们可以尽可能的将错误细化，比如下面枚举类中参数错误，空指针异常等。

创建一个 `com.shiyanlou.file.common` 包用来存放一些公共类，创建返回码的枚举类 `ResultCodeEnum.java` 放到这个包下面，如下：

```java
package com.shiyanlou.file.common;

import lombok.Getter;

/**
 * 结果类枚举
 */
@Getter
public enum ResultCodeEnum {
    SUCCESS(true,20000,"成功"),
    UNKNOWN_ERROR(false,20001,"未知错误"),
    PARAM_ERROR(false,20002,"参数错误"),
    NULL_POINT(false, 20003, "空指针异常"),
    INDEX_OUT_OF_BOUNDS(false, 20004, "下标越界异常"),
    ;

    // 响应是否成功
    private Boolean success;
    // 响应状态码
    private Integer code;
    // 响应信息
    private String message;

    ResultCodeEnum(boolean success, Integer code, String message) {
        this.success = success;
        this.code = code;
        this.message = message;
    }
}
```

### 定义统一结果返回类



在 `com.shiyanlou.file.common` 包下继续定义 `RestResult.java` 类，该类用于定义后台统一返回格式。

```java
package com.shiyanlou.file.common;

import lombok.Data;

/**
 * 统一结果返回
 *
 * @param <T>
 */
@Data
public class RestResult<T> {
    private Boolean success = true;
    private Integer code;
    private String message;
    private T data;

    // 通用返回成功
    public static RestResult success() {
        RestResult r = new RestResult();
        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());
        r.setCode(ResultCodeEnum.SUCCESS.getCode());
        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());
        return r;
    }

    // 通用返回失败，未知错误
    public static RestResult fail() {
        RestResult r = new RestResult();
        r.setSuccess(ResultCodeEnum.UNKNOWN_ERROR.getSuccess());
        r.setCode(ResultCodeEnum.UNKNOWN_ERROR.getCode());
        r.setMessage(ResultCodeEnum.UNKNOWN_ERROR.getMessage());
        return r;
    }

}
```

### 返回结果测试



接下来我们对上面的代码进行测试，创建一个 `com.shiyanlou.file.controller` 包用来存放接口，在包下创建文件：`UserController.java`，打开该文件，初始化内容如下：

```java
package com.shiyanlou.file.controller;

import com.shiyanlou.file.common.RestResult;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/user")
public class UserController {

    /**
     * 成功响应测试
     */
    @GetMapping(value="/test1")
    @ResponseBody
    public RestResult test1(){
        return RestResult.success();
    }

    /**
     * 失败响应测试
     */
    @GetMapping(value="/test2")
    @ResponseBody
    public RestResult test2(){
        return RestResult.fail();
    }
}
```

启动项目进行测试（`Application.java` 文件），启动成功之后，点击右侧 Web 服务进行测试，在浏览器上面的地址栏追加内容：`/user/test1`，查看后台返回，如下图是模拟成功响应：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/72cf062441559f832ab255b2cce61072-0)

在浏览器上面的地址栏追加内容： `/user/test2`，查看后台返回，如下图是模拟失败响应：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/8e60c726fb45d7486a36493fd37ea29f-0)

上面这段代码我们可以称它们为通用的成功或失败响应码，但是有些情况，当系统返回失败的时候我们需要自定义返回码或者返回信息，因此需要在 RestResult 结果类里面添加方法，来满足各种错误场景。

打开 `RestResult.java` 类，添加如下代码：

```java
// 自定义返回数据
public RestResult data(T param) {
    this.setData(param);
    return this;
}

// 自定义状态信息
public RestResult message(String message) {
    this.setMessage(message);
    return this;
}

// 自定义状态码
public RestResult code(Integer code) {
    this.setCode(code);
    return this;
}

// 设置结果，形参为结果枚举
public static RestResult setResult(ResultCodeEnum result) {
    RestResult r = new RestResult();
    r.setSuccess(result.getSuccess());
    r.setCode(result.getCode());
    r.setMessage(result.getMessage());
    return r;
}
```

上面这三个方法分别用来自定义返回数据，状态码和状态信息，具体的使用方法如下：

```java
//查询文件列表
public RestResult list() {
    List<File> filelist = new ArrayList<File>();
    //获取文件列表（略）
    ...
    return RestResult.fail().data(filelist);
}

//模拟用户登录失败响应场景
public RestResult loginFailResult() {
    return RestResult.fail().message("手机号不存在！");
}
```

### 统一异常处理



在我们编程的过程中，并不是百分之百的接口都能通过正常的方式调用及返回，往往还会有一些异常场景，比如代码中经常出现数据下标越界，空指针异常等异常场景，而这些场景都是不可控的，一旦发生，程序流程就会终止，此时如果不对这种场景进行处理，那么就会造成前台无响应的局面。

### 异常处理类



异常处理类的原理就是通过 AOP 进行拦截，AOP 就是面向切面编程，而我们这里使用的切面实在控制层进行切面拦截，当发生异常时就会执行异常处理类。

创建 `com.shiyanlou.file.advice` 包，在这个包下新建 `GlobalExceptionHandlerAdvice.java`, 代码如下：

```java
package com.shiyanlou.file.advice;

import com.shiyanlou.file.common.RestResult;

import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@ControllerAdvice
public class GlobalExceptionHandlerAdvice {
    /**-------- 通用异常处理方法 --------**/
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public RestResult error(Exception e) {
        e.printStackTrace();
        log.error("全局异常捕获：" + e);

        return RestResult.fail();    // 通用异常结果
    }
}
```

上面代码涉及到几个重要的注解，说明如下表：

| 注解              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| @ControllerAdvice | 这是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能：1、全局异常处理， 2、全局数据绑定， 3、全局数据预处理 |
| @ExceptionHandler | 该注解用来指明异常的处理类型                                 |
| @ResponseBody     | 该注解为 Spring Boot 响应体注解，用在这里的目的就是当出现异常时，直接将错误返回给前台，可以避免前台页面阻塞 |

上面我们使用了大异常 `Exception` 来进行处理，不管发生任何异常都会执行该方法，当然在实际当中，我们也可以将异常进行细化，使得前台返回的错误更加具体，继续在该 `GlobalExceptionHandlerAdvice.java` 文件中添加下面代码：

```java
import com.shiyanlou.file.common.ResultCodeEnum;

@Slf4j
@ControllerAdvice
public class GlobalExceptionHandlerAdvice {
    ...
    @ExceptionHandler(NullPointerException.class)
    @ResponseBody
    //空指针处理方法
    public RestResult error(NullPointerException e) {
        e.printStackTrace();
        log.error("全局异常捕获：" + e);
        return RestResult.setResult(ResultCodeEnum.NULL_POINT);
    }

    //下标越界处理方法
    @ExceptionHandler(IndexOutOfBoundsException.class)
    @ResponseBody
    public RestResult error(IndexOutOfBoundsException e) {
        e.printStackTrace();
        log.error("全局异常捕获：" + e);
        return RestResult.setResult(ResultCodeEnum.INDEX_OUT_OF_BOUNDS);
    }
}
```

### session 与 token 发展历程



我们都知道，一个普通 Web 应用前后台进行交互使用的是 HTTP 协议，由于 HTTP 协议是无状态的，因此每个请求对于后台服务端来说，都是全新的，但是随着互联网的 Web 应用兴起，像很多购物网站，需要登录的网站就面临一个问题，那就是会话管理，后台需要记住哪些人登录系统，哪些人进行了购物操作，也就是说必须把每个人区分开，但是 HTTP 请求时无状态的，所以就想到一个办法，给每个请求者发一个会话标识，也就是 session，说白了就是一个随机的字符串，保证每个人不重复，这样当大家再次向服务端发送请求的时候，就能区分开来谁是谁了。

随着用户数量的增加，服务器要保存所有用户的 session，这对服务器来说是一个巨大的开销，严重的限制了服务器的扩展能力，比如负载均衡+服务器集群部署方式，往往用户在 A 服务器登录了系统，session 会保存在机器 A 上，但是如果下一次请求被转发到了机器 B 怎么办？通常有两种做法，一种是通过 Sticky 技术将相同用户请求分发到同一个机器上，但是这样就违背了做负载均衡的初衷了，而且万一这个机器挂了，那么还是会请求到另外的机器上。另一种做法就 session 的复制了，将 session 在多个应用之间进行复制，如下图：

![图片描述](后端一.assets/f2fa9ecf92b1f56bced1a10bc651ead7-0)

但是集群的数量如果过大，将 session 拷来拷去，却是一件很麻烦的事情，因此，有人支招，将 session 集中存储到一个地方，所有机器都来访问这个地方的数据，这样一来，就不用复制了，如下：

![图片描述](后端一.assets/fa008106d06141c062e48b8cb6506978-0)

但是如果这个 session 存储的机器挂了，所有人都得受到影响，因此也尝试将这个机器也搞一个集群，增加可靠性，但是不管如何，这个小小的 session 对后台来说都是一个沉重的负担。

于是又有人思考，为什么后台要保存这些 session 呢？如果让每个客户端自己去保存该有多好，出于这个起点，人们开始不断的尝试。关键点在于如果服务端不保存 session，如何知道 session 是我生成的。关键点就在于验证，比如客户端 M 登录了系统，我给他发了一个令牌(token),里面包含了该用户的 user id，用来标识客户端身份,下次客户端 M 再次访问我的时候，再把这个 token 通过 Http header 带过来就行了，不过这个本质和 session 没区别，任何人都可以伪造，所以得想点办法，让别人无法伪造。

那就对数据做个签名，将数据和密钥一起作为 token，由于密钥别人不知道，就无法伪造 token 了。当客户端再次进行请求，服务端只需要用密钥再次签名进行验证，如果签名一致，则为有效 token，这时就可以直接取到 user id，如果签名不一致，则说明数据被篡改了，则告诉请求者，认证失败。

### Java Web Token 概念



JSON Web Token (JWT) 是一个开放标准（RFC 7519），它定义了一种紧凑且自包含的方式，用于将信息作为 JSON 对象安全地在各方之间传输信息。此信息可以验证和信任，因为它是数字签名。JWT 可以使用密钥（使用 HMAC 算法）或使用 RSA 或 ECDSA 进行公钥/私钥对进行签名。

#### JWT 结构

JSON Web 令牌以紧凑的形式由三个部分组成，由点（.）分隔，它们包括：

- Header
- Payload
- Signature

将上面三部分用（.）拼接起来就形成了 JWT，因此，JWT 的格式通常如下所示。

```
xxxxx.yyyyy.zzzzz
```

#### Header

标头通常由两部分组成：token 的类型（typ）和正在使用的签名算法（alg），如 HMAC SHA256 或 RSA。

例如：

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

然后，此 JSON 编码为 Base64Url，以形成 JWT 的第一部分。

#### Payload

token 的第二部分是有效负载，其中包含 claims。claims 是关于实体（通常为用户）和其他数据的语句。

示例有效负载可能是：

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

然后对有效负载进行 Base64Url 编码，以形成 JSON Web 令牌的第二部分。

请注意，对于已签名的 token，此信息虽然可防止篡改，但任何人都可以阅读。除非对 JWT 进行加密，否则不要将机密信息放在 JWT 的有效负载或标头元素中。

#### Signature

要创建签名部分，您必须使用编码标头、编码有效负载、机密、标头中指定的算法，并签名。

例如，如果要使用 HMAC SHA256 算法，将采用以下方式创建签名：

```java
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

签名用于验证信息在传输过程中不被篡改，对于使用私钥签名的 token，它还可以验证 JWT 的发件人是否为它所说的发件人。

#### 放在一起



输出是三个 Base64-URL 字符串，由点分隔，这些点可以在 HTML 和 HTTP 环境中轻松传递，但与基于 XML 的标准（如 SAML）相比，更紧凑。

#### 添加依赖



向 `pom.xml` 添加如下依赖：

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

#### 添加配置文件



上面已经介绍了 JWT 的基本概念了，它由三部分构成，分别是 header, payload 和 signature, 其中前两部分中的参数设计到的一些参数需要用户自定义，因此我们将这些参数放到配置文件中，方便后续修改。

打开 `application.properties` 文件，添加如下配置：

```properties
# 密钥
jwt.secret = 6L6T5LqG5L2g77yM6LWi5LqG5LiW55WM5Y+I6IO95aaC5L2V44CC
# 签名算法：HS256,HS384,HS512,RS256,RS384,RS512,ES256,ES384,ES512,PS256,PS384,PS512
jwt.header.alg = HS256
#jwt签发者
jwt.payload.registerd-claims.iss = 
#jwt过期时间（单位：毫秒）
jwt.payload.registerd-claims.exp = 60 * 60 * 1000 * 24 * 7
#jwt接收者
jwt.payload.registerd-claims.aud = boyun
```

### 添加 JWT 配置属性类



创建包 `com.shiyanlou.file.config.jwt`, 然后新增四个配置类如下：

JwtHeader 属性类用来定义 JWT 第一部分，代码如下：

```java
package com.shiyanlou.file.config.jwt;

import lombok.Data;

@Data
public class JwtHeader {
    private String alg;
    private String typ;
}
```

JwtPayload 属性类用来定义 JWT 第二部分，代码如下：

```java
package com.shiyanlou.file.config.jwt;

import lombok.Data;

@Data
public class JwtPayload {
    private RegisterdClaims registerdClaims;
}
package com.shiyanlou.file.config.jwt;

import lombok.Data;

@Data
public class RegisterdClaims {
    private String iss;
    private String exp;
    private String sub;
    private String aud;
}
```

接下来我们将上面的属性类组织起来，形成一个完整的 JWT 配置类 JwtProperties, 该类使用 ConfigurationProperties 注解，其中的 prefix 参数是 jwt，可以读取 `application.properties` 配置文件中以 jwt 开头的配置，代码如下：

```java
package com.shiyanlou.file.config.jwt;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Data
@Component
@ConfigurationProperties(prefix = "jwt")
public class JwtProperties {
    private String secret;
    private JwtHeader header;
    private JwtPayload payload;
}
```

#### 初始化



向 `JWTUtil.java` 文件中添加如下代码进行初始化：

```java
package com.shiyanlou.file.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.impl.DefaultClaims;

import org.apache.tomcat.util.codec.binary.Base64;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import com.shiyanlou.file.config.jwt.JwtProperties;

import java.util.Date;

@Component
public class JwtUtil {

    @Resource
    JwtProperties jwtProperties;

}
```

### 添加生成密钥方法



在 `JWTUtil.java` 中创建 generalSecretKey 方法来生成密钥，生成的过程需要使用 JWT 的方法 SecretKeySpec 来生成密钥，该密钥在创建 JWT 和验证 JWT 的时候都会用到且相同，代码如下：

```java
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import org.apache.tomcat.util.codec.binary.Base64;

public class JWTUtil {
    ...
    /**
     * 由字符串生成加密key
     * @return
     */
    private SecretKey generalKey() {
        // 本地的密码解码
        byte[] encodedKey = Base64.decodeBase64(jwtProperties.getSecret());
        // 根据给定的字节数组使用AES加密算法构造一个密钥
        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, "AES");
        return key;
    }
}
```

### 创建 JWT 方法



继续向 `JWTUtil.java` 文件中补充如下代码：

```java
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;

public class JWTUtil {
    ....

    /**
     * 创建jwt
     * @param subject
     * @return
     * @throws Exception
     */
    public String createJWT(String subject) throws Exception {

        // 生成JWT的时间
        long nowTime = System.currentTimeMillis();
        Date nowDate = new Date(nowTime);
        // 生成签名的时候使用的秘钥secret，切记这个秘钥不能外露，是你服务端的私钥，在任何场景都不应该流露出去，一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt的
        SecretKey key = generalKey();

        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine se = manager.getEngineByName("js");
        int expireTime = 0;
        try {
            expireTime =(int) se.eval(jwtProperties.getPayload().getRegisterdClaims().getExp());
        } catch (ScriptException e) {
            e.printStackTrace();
        }

        // 为payload添加各种标准声明和私有声明
        DefaultClaims defaultClaims = new DefaultClaims();
        defaultClaims.setIssuer(jwtProperties.getPayload().getRegisterdClaims().getIss());
        defaultClaims.setExpiration(new Date(System.currentTimeMillis() + expireTime));
        defaultClaims.setSubject(subject);
        defaultClaims.setAudience(jwtProperties.getPayload().getRegisterdClaims().getAud());

        JwtBuilder builder = Jwts.builder() // 表示new一个JwtBuilder，设置jwt的body
                .setClaims(defaultClaims)
                .setIssuedAt(nowDate) // iat(issuedAt)：jwt的签发时间
                .signWith(SignatureAlgorithm.forName(jwtProperties.getHeader().getAlg()), key); // 设置签名，使用的是签名算法和签名使用的秘钥

        return builder.compact();
    }
}
```

### 解析 JWT 方法



继续向 `JWTUtil.java` 文件中补充如下代码：

```java
import io.jsonwebtoken.Claims;

public class JWTUtil {
    ...
    /**
     * 解密jwt
     * @param jwt
     * @return
     * @throws Exception
     */
    public Claims parseJWT(String jwt) throws Exception {
        SecretKey key = generalKey(); // 签名秘钥，和生成的签名的秘钥一模一样
        Claims claims = Jwts.parser() // 得到DefaultJwtParser
                .setSigningKey(key) // 设置签名的秘钥
                .parseClaimsJws(jwt).getBody(); // 设置需要解析的jwt
        return claims;
    }
}
```

### 注册逻辑实现



创建包 `com.shiyanlou.file.service` ，在该包下面新增 `UserService.java` 类，该类为 Service 层的接口，然后继续创建包 `com.shiyanlou.service.impl`，在该包下新增 `UserServiceImpl.java` 类，用来作为 `UserService.java` 的实现类

### 初始化 UserService.java



```java
package com.shiyanlou.file.service;

import com.shiyanlou.file.common.RestResult;
import com.shiyanlou.file.model.User;

public interface UserService {
    RestResult<String> registerUser(User user);
}
```

### 初始化 UserServiceImpl.java



```java
package com.shiyanlou.file.service.impl;

import java.util.List;
import java.util.UUID;

import javax.annotation.Resource;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.shiyanlou.file.common.RestResult;
import com.shiyanlou.file.mapper.UserMapper;
import com.shiyanlou.file.model.User;
import com.shiyanlou.file.service.UserService;
import com.shiyanlou.file.util.DateUtil;

import org.springframework.stereotype.Service;
import org.springframework.util.DigestUtils;
import org.springframework.util.StringUtils;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService{

    @Resource
    UserMapper userMapper;

    @Override
    public RestResult<String> registerUser(User user) {
        //判断验证码
        String telephone = user.getTelephone();
        String password = user.getPassword();

        if (!StringUtils.hasLength(telephone) || !StringUtils.hasLength(password)){
            return RestResult.fail().message("手机号或密码不能为空！");
        }
        if (isTelePhoneExit(telephone)){
            return RestResult.fail().message("手机号已存在！");
        }


        String salt = UUID.randomUUID().toString().replace("-", "").substring(15);
        String passwordAndSalt = password + salt;
        String newPassword = DigestUtils.md5DigestAsHex(passwordAndSalt.getBytes());

        user.setSalt(salt);

        user.setPassword(newPassword);
        user.setRegisterTime(DateUtil.getCurrentTime());
        int result = userMapper.insert(user);

        if (result == 1) {
            return RestResult.success();
        } else {
            return RestResult.fail().message("注册用户失败，请检查输入信息！");
        }
    }

    private boolean isTelePhoneExit(String telePhone) {
        LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(User::getTelephone, telePhone);
        List<User> list = userMapper.selectList(lambdaQueryWrapper);
        if (list != null && !list.isEmpty()) {
            return true;
        } else {
            return false;
        }

    }

}
```

向 `com.shiyanlou.file.util` 模块中添加 `DateUtil.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.util;

import java.util.Date;

public class DateUtil {
    /**
     * 获取系统当前时间
     *
     * @return 系统当前时间
     */
    public static String getCurrentTime() {
        Date date = new Date();
        String stringDate = String.format("%tF %<tT", date);
        return stringDate;
    }

}
```

### 登录接口方法



打开 `UserService.java` 类，新增如下接口方法：

```java
RestResult<User> login(User user);
```

### 登录接口实现



打开 `UserServiceImpl.java` 类，新增 `login` 接口方法实现：

```java
@Override
public RestResult<User> login(User user) {
    String telephone = user.getTelephone();
    String password = user.getPassword();

    LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    lambdaQueryWrapper.eq(User::getTelephone, telephone);
    User saveUser = userMapper.selectOne(lambdaQueryWrapper);
    String salt = saveUser.getSalt();
    String passwordAndSalt = password + salt;
    String newPassword = DigestUtils.md5DigestAsHex(passwordAndSalt.getBytes());
    if (newPassword.equals(saveUser.getPassword())) {
        saveUser.setPassword("");
        saveUser.setSalt("");
        return RestResult.success().data(saveUser);
    } else {
        return RestResult.fail().message("手机号或密码错误！");
    }

}
```

### 使用 Java Web Token 实现用户登录认证



首先我们需要在 `UserController.java` 中创建两个接口，分别是登录和注册，前面我们已经将 `UserService.java` 接口和实现类完成了，这里我们只需要注入就可以使用了。

```java
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import javax.annotation.Resource;
import com.shiyanlou.file.service.UserService;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {
    @Resource
    UserService userService;
    ...
}
```

### 前台注册接口



创建包 `com.shiyanlou.file.dto` 用来存放接口请求参数，在该包下面创建 `RegisterDTO.java`，并初始化内容如下：

```java
package com.shiyanlou.file.dto;

import lombok.Data;

@Data
public class RegisterDTO {
    private String username;
    private String telephone;
    private String password;
}
```

接下来在 `UserController.java` 中，添加注册方法，代码如下：

```java
import com.shiyanlou.file.dto.RegisterDTO;
import com.shiyanlou.file.model.User;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {
    ...
    @PostMapping(value = "/register")
    @ResponseBody
    public RestResult<String> register(@RequestBody RegisterDTO registerDTO) {
        RestResult<String> restResult = null;
        User user = new User();
        user.setUsername(registerDTO.getUsername());
        user.setTelephone(registerDTO.getTelephone());
        user.setPassword(registerDTO.getPassword());

        restResult = userService.registerUser(user);

        return restResult;
    }
}
```

### 前台登录接口



创建包 `com.shiyanlou.file.vo` 用来存放接口响应参数，在该包下面创建 `LoginVO.java`，并初始化内容如下：

```java
package com.shiyanlou.file.vo;

import lombok.Data;

@Data
public class LoginVO {
    private String username;
    private String token;
}
```

接下来在 `UserController.java` 中，添加登录方法，代码如下：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.shiyanlou.file.util.JWTUtil;
import com.shiyanlou.file.vo.LoginVO;

@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {

    @Resource
    JWTUtil jwtUtil;

    ...
    @GetMapping(value = "/login")
    @ResponseBody
    public RestResult<LoginVO> userLogin(String telephone, String password) {
        RestResult<LoginVO> restResult = new RestResult<LoginVO>();
        LoginVO loginVO = new LoginVO();
        User user = new User();
        user.setTelephone(telephone);
        user.setPassword(password);
        RestResult<User> loginResult = userService.login(user);

        if (!loginResult.getSuccess()) {
            return RestResult.fail().message("登录失败！");
        }

        loginVO.setUsername(loginResult.getData().getUsername());
        String jwt = "";
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            jwt = jwtUtil.createJWT(objectMapper.writeValueAsString(loginResult.getData()));
        } catch (Exception e) {
            return RestResult.fail().message("登录失败！");
        }
        loginVO.setToken(jwt);

        return RestResult.success().data(loginVO);
    }
}
```

### token 校验接口



用户登录成功后，可以调用该接口来获取登录状态，判断 token 是否失效，保证前后台登录状态一致。

继续向 `UserController.java` 文件中添加如下代码：

```java
import org.springframework.web.bind.annotation.RequestHeader;
import io.jsonwebtoken.Claims;

@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {
    ...
    @GetMapping("/checkuserlogininfo")
    @ResponseBody
    public RestResult<User> checkToken(@RequestHeader("token") String token) {
        RestResult<User> restResult = new RestResult<User>();
        User tokenUserInfo = null;
        try {

            Claims c = jwtUtil.parseJWT(token);
            String subject = c.getSubject();
            ObjectMapper objectMapper = new ObjectMapper();
            tokenUserInfo = objectMapper.readValue(subject, User.class);

        } catch (Exception e) {
            log.error("解码异常");
            return RestResult.fail().message("认证失败");

        }

        if (tokenUserInfo != null) {

            return RestResult.success().data(tokenUserInfo);

        } else {
            return RestResult.fail().message("用户暂未登录");
        }
    }
}
```

上面这段代码，如果 token 不正确，或者 token 过期，就会导致解码失败，返回认证失败，如果能够正确解析，那么就会返回成功。
### Swagger 基本概念



Swagger 是一个 API 文档维护组织，后来成为了 Open API 标准的主要定义者，现在最新的版本为 17 年发布的 Swagger3。

Swagger 是一个规范和完整的框架，用于生成可视化 RESTful 风格的 Web 服务。

如果想要将 Swagger 文档集成到 Spring 中，目前有两个开源项目可供开发者选择，一个是 SpringFox，另一个是 SpringDoc，这两个项目都是由 Spring 社区来维护的，在 Swagger 2.0 时代，SpringFox 是主流，但是随着 Swagger 3.0 版本发布之后，SpringDoc 对最新版本的兼容性更好，而且 SpringDoc 支持 Swagger 页面 Oauth2 登录，因此使用 SpringDoc 是更好的选择，下面我将主要介绍 SpringDoc 集成。

##### 添加依赖



向 `pom.xml` 文件中添加如下依赖：

```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-ui</artifactId>
    <version>1.5.4</version>
</dependency>
```

#### 添加配置类



在 `com.shiyanlou.file.config` 包下创建 `OpenApiConfig.java` 文件，写入如下代码：

```java
package com.shiyanlou.file.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.swagger.v3.oas.models.ExternalDocumentation;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;

@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI qiwenFileOpenAPI() {
        return new OpenAPI()
                .info(new Info().title("网盘项目 API")
                        .description("基于springboot + vue 框架开发的Web文件系统，旨在为用户提供一个简单、方便的文件存储方案，能够以完善的目录结构体系，对文件进行管理 。")
                        .version("v1.0.0")
                        .license(new License().name("MIT").url("http://springdoc.org")))
                .externalDocs(new ExternalDocumentation()
                        .description("网盘gitee地址")
                        .url("https://www.gitee.com/qiwen-cloud/qiwen-file"));
    }
}
```



#### 注解介绍



#### @Tag 注解

该注解可以用在类或方法上，当作用在方法是用来定义单个操作，当作用在类上代表所有操作。

| 属性         | 描述                     |
| ------------ | ------------------------ |
| name         | 标签名                   |
| description  | 这里可以做一个简短的描述 |
| externalDocs | 添加一个扩展文档         |
| extensions   | 可选的扩展列表           |

#### @Operation 注解

该注解可用于将资源方法定义为 OpenAPI 操作，在该注解中也可以定义该操作的其他属性。

| 属性        | 描述                           |
| ----------- | ------------------------------ |
| method      | HTTP 请求方法                  |
| tags        | 按照资源对操作进行逻辑分组     |
| summary     | 提供此操作的简要说明。         |
| description | 对操作的详细描述               |
| requestBody | 与操作关联的请求报文           |
| parameters  | 一个可选的参数数组             |
| responses   | 执行此操作返回的可能响应的列表 |
| deprecated  | 允许将操作标记为已弃用         |
| security    | 可用于此操作的安全机制的声明。 |

#### @Schema 注解

该注解用来定义模型，主要用来定义模型类及模型的属性，请求和响应的内容、报文头等。

| 属性        | 描述                             |
| ----------- | -------------------------------- |
| not         | 提供用于禁止匹配属性的 java 类。 |
| name        | 用于描述模型类或属性的名称       |
| title       | 用于描述模型类的标题             |
| maximum     | 设置属性的最大数值。             |
| minimum     | 设置属性的最小数值。             |
| maxLength   | 设置字符串值的最大长度。         |
| minLength   | 设置字符串值的最大小度。         |
| pattern     | 值必须满足的模式。               |
| required    | 是否必输                         |
| description | 描述                             |
| nullable    | 如果为 true 则可能为 null。      |
| example     | 使用示例                         |

#### 代码实现



#### 添加 Controller 接口信息

打开 `UserController.java` 类，在类上添加 `@Tag` 标签用来描述一组操作的信息，在方法上面添加 `@Operation` 注解，用来描述接口信息，代码如下：

```java
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;

@Tag(name = "user", description = "该接口为用户接口，主要做用户登录，注册和校验token")
@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {

    ...
    @Operation(summary = "用户注册", description = "注册账号", tags = {"user"})
    @PostMapping(value = "/register")
    @ResponseBody
    public RestResult<String> addUser(@RequestBody RegisterDTO registerDTO) {
        ...
    }

    @Operation(summary = "用户登录", description = "用户登录认证后才能进入系统", tags = {"user"})
    @GetMapping("/login")
    @ResponseBody
    public RestResult<LoginVO> userLogin(String telephone, String password) {
        ...
    }

    @Operation(summary = "检查用户登录信息", description = "验证token的有效性", tags = {"user"})
    @GetMapping("/checkuserlogininfo")
    @ResponseBody
    public RestResult<User> checkToken(@RequestHeader("token") String token) {

    }

}
```

#### 添加实体类信息

在此之前我们在接口层使用了两个实体类，分别是 `RegisterDTO.java` 和 `LoginVO.java`，然后现在我们添加该实体类注解：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Schema(description="注册DTO")
@Data
public class RegisterDTO {
    @Schema(description="用户名")
    private String username;
    @Schema(description="手机号")
    private String telephone;
    @Schema(description="密码")
    private String password;
}
package com.shiyanlou.file.vo;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Schema(description="登录VO")
@Data
public class LoginVO {
    @Schema(description="用户名")
    private String username;
    @Schema(description="token")
    private String token;
}
```

#### 启动项目



启动 MySQL 数据库：

```bash
sudo service mysql start
```

点击 run 启动项目，在控制台查看项目启动成功之后，点击右侧 Web 服务进行访问，在浏览器页面地址后面追加 `/swagger-ui.html` 

### 文件代码类创建



在之前数据库设计的时候，关于文件操作主要有两张表，分别是 `file` 和 `userfile` 表，下面我们完善这两张表基础代码。

### Mapper 层接口



在 `com.shiyanlou.file.mapper` 下之前已经创建好了 `FileMapper.java` 和 `UserfileMapper.java` 接口类，现在我们将这两个类都继承 BaseMapper，以便我们之后使用 MyBatis-Plus 来操作数据库，代码如下：

#### FileMapper 接口

```java
package com.shiyanlou.file.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.shiyanlou.file.model.File;

public interface FileMapper extends BaseMapper<File> {

}
```

#### UserfileMapper 接口

```java
package com.shiyanlou.file.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.shiyanlou.file.model.UserFile;

public interface UserfileMapper extends BaseMapper<UserFile> {

}
```

### Service 接口



在 `com.shiyanlou.file.service` 包下创建文件 Service 层接口 `FileService.java`，并初始化如下内容：

```java
package com.shiyanlou.file.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.shiyanlou.file.model.File;

public interface FileService extends IService<File> {

}
```

在 `com.shiyanlou.file.service` 包下创建用户文件 Service 层接口 `UserfileService.java`，并初始化如下内容：

```java
package com.shiyanlou.file.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.shiyanlou.file.model.UserFile;

public interface UserfileService extends IService<UserFile> {

}
```

### Service 实现



在 `com.shiyanlou.file.service.impl` 包下创建 `FileService.java` 接口的实现类 `FileServiceImpl.java`，代码如下：

```java
package com.shiyanlou.file.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.shiyanlou.file.mapper.FileMapper;
import com.shiyanlou.file.model.File;
import com.shiyanlou.file.service.FileService;

import org.springframework.stereotype.Service;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class FileServiceImpl extends ServiceImpl<FileMapper, File> implements FileService {

}
```

在 `com.shiyanlou.file.service.impl` 包下创建 `UserfileService.java` 接口的实现类 `UserfileServiceImpl.java`，代码如下：

```java
package com.shiyanlou.file.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.shiyanlou.file.mapper.UserfileMapper;
import com.shiyanlou.file.model.UserFile;
import com.shiyanlou.file.service.UserfileService;

import org.springframework.stereotype.Service;

@Service
public class UserfileServiceImpl extends ServiceImpl<UserfileMapper, UserFile> implements UserfileService {

}
```

在 `UserServiceImpl.java` 中添加 `getUserByToken` 方法，该方法通过 token 获取到用户信息，后面会频繁用到，可以用来校验 token，此段代码依赖 JWTUtil，需要在顶部注入，代码如下：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.shiyanlou.file.util.JWTUtil;
import io.jsonwebtoken.Claims;

@Slf4j
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService{

    @Resource
    JWTUtil jwtUtil;
    ...
    @Override
    public User getUserByToken(String token) {
        User tokenUserInfo = null;
        try {

            Claims c = jwtUtil.parseJWT(token);
            String subject = c.getSubject();
            ObjectMapper objectMapper = new ObjectMapper();
            tokenUserInfo = objectMapper.readValue(subject, User.class);

        } catch (Exception e) {
            log.error("解码异常");
            return null;

        }
        return tokenUserInfo;
    }
}
```

当调用该方法，如果返回 null，则认为 token 是无效的。

向 `UserService.java` 文件中补充如下代码：

```java
    User getUserByToken(String token);
```

### 文件夹创建接口开发



#### DTO 实体类

在 `com.shiyanlou.file.dto` 包下创建 `CreateFileDTO.java` 实体类，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "创建文件DTO",required = true)
public class CreateFileDTO {
    @Schema(description="文件名")
    private String fileName;
    @Schema(description="文件路径")
    private String filePath;
}
```

#### Controller 控制器层

在 `com.shiyanlou.file.controller` 包下创建 `FileController.java` 实体类，并增加文件夹创建接口，接口代码如下：

```java
package com.shiyanlou.file.controller;

import java.util.List;

import javax.annotation.Resource;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.shiyanlou.file.common.RestResult;
import com.shiyanlou.file.dto.CreateFileDTO;
import com.shiyanlou.file.model.User;
import com.shiyanlou.file.model.UserFile;
import com.shiyanlou.file.service.FileService;
import com.shiyanlou.file.service.UserService;
import com.shiyanlou.file.service.UserfileService;
import com.shiyanlou.file.util.DateUtil;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.extern.slf4j.Slf4j;


@Tag(name = "file", description = "该接口为文件接口，主要用来做一些文件的基本操作，如创建目录，删除，移动，复制等。")
@RestController
@Slf4j
@RequestMapping("/file")
public class FileController {

    @Resource
    FileService fileService;
    @Resource
    UserService userService;
    @Resource
    UserfileService userfileService;

    @Operation(summary = "创建文件", description = "目录(文件夹)的创建", tags = {"file"})
    @PostMapping(value = "/createfile")
    @ResponseBody
    public RestResult<String> createFile(@RequestBody CreateFileDTO createFileDto, @RequestHeader("token") String token) {


        User sessionUser = userService.getUserByToken(token);
        if (sessionUser == null) {
            RestResult.fail().message("token认证失败");
        }
        LambdaQueryWrapper<UserFile> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(UserFile::getFileName, "").eq(UserFile::getFilePath, "").eq(UserFile::getUserId, 0);
        List<UserFile> userfiles = userfileService.list(lambdaQueryWrapper);
        if (!userfiles.isEmpty()) {
            RestResult.fail().message("同目录下文件名重复");
        }

        UserFile userFile = new UserFile();
        userFile.setUserId(sessionUser.getUserId());
        userFile.setFileName(createFileDto.getFileName());
        userFile.setFilePath(createFileDto.getFilePath());
        userFile.setIsDir(1);
        userFile.setUploadTime(DateUtil.getCurrentTime());

        userfileService.save(userFile);
        return RestResult.success();
    }
}
```

### 文件列表查询接口开发



#### DTO 实体类

创建 DTO 实体类 `UserfileListDTO.java`，用来作为文件列表查询接口接收前台请求信息的载体，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "文件列表DTO",required = true)
public class UserfileListDTO {
    @Schema(description = "文件路径")
    private String filePath;
    @Schema(description = "当前页码")
    private Long currentPage;
    @Schema(description = "一页显示数量")
    private Long pageCount;
}
```

#### VO 实体类

创建 VO 实体类 `UserfileListVO.java`，用来作为文件列表查询接口给前台返回的信息载体，代码如下：

```java
package com.shiyanlou.file.vo;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(description="用户文件列表VO")
public class UserfileListVO {
    @Schema(description="文件id")
    private Long fileId;
    @Schema(description="时间戳名称")
    private String timeStampName;
    @Schema(description="文件url")
    private String fileUrl;
    @Schema(description="文件大小")
    private Long fileSize;
    @Schema(description="是否是oss存储")
    private Integer isOSS;
    @Schema(description="引用数量")
    private Integer pointCount;
    @Schema(description="md5")
    private String identifier;
    @Schema(description="用户文件id")
    private Long userFileId;
    @Schema(description="用户id")
    private Long userId;

    @Schema(description="文件名")
    private String fileName;
    @Schema(description="文件路径")
    private String filePath;
    @Schema(description="扩展名")
    private String extendName;
    @Schema(description="是否是目录")
    private Integer isDir;
    @Schema(description="上传时间")
    private String uploadTime;
}
```

#### DAO 层代码编写

在 `resources/mybatis/mapper` 路径下创建 `UserfileMapper.xml`，并初始化内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.shiyanlou.file.mapper.UserfileMapper">

</mapper>
```

在 `UserfileMapper.xml` 文件中创建用户文件分页查询 sql，代码如下：

```xml
...
<mapper namespace="com.shiyanlou.file.mapper.UserfileMapper">

    <select id="userfileList" resultType="com.shiyanlou.file.vo.UserfileListVO">
        select * from userfile a
        left join file on file.fileId = a.fileId
        <where>
            <if test="userfile.userId != null">
                and a.userId = #{userfile.userId}
            </if>
            <if test="userfile.filePath != null">
                and a.filePath = #{userfile.filePath}
            </if>
            <if test="userfile.extendName != null">
                and a.extendName = #{userfile.extendName}
            </if>
        </where>
        ORDER BY  isDir desc
        limit #{beginCount}, #{pageCount}
    </select>

</mapper>
```

在 `UserfileMapper.java` 接口类中，新增文件查询接口，代码如下：

```java
...
import java.util.List;
import com.shiyanlou.file.vo.UserfileListVO;

public interface UserfileMapper extends BaseMapper<UserFile> {
    List<UserfileListVO> userfileList(UserFile userfile, Long beginCount, Long pageCount);

}
```

#### Service 层代码编写

在 `UserfileService.java` 接口类中，新增获取文件列表接口，代码如下：

```java
import java.util.List;
import com.shiyanlou.file.vo.UserfileListVO;

public interface UserfileService extends IService<UserFile> {
    List<UserfileListVO> getUserFileByFilePath(String filePath, Long userId, Long currentPage, Long pageCount);
}
```

在 `UserfileServiceImpl.java` 中新增获取文件列表方法实现，代码如下：

```java
package com.shiyanlou.file.service.impl;

import java.util.List;

import javax.annotation.Resource;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.shiyanlou.file.mapper.UserfileMapper;
import com.shiyanlou.file.model.UserFile;
import com.shiyanlou.file.service.UserfileService;
import com.shiyanlou.file.vo.UserfileListVO;
import org.springframework.stereotype.Service;

@Service
public class UserfileServiceImpl extends ServiceImpl<UserfileMapper, UserFile> implements UserfileService {

    @Resource
    UserfileMapper userfileMapper;

    @Override
    public List<UserfileListVO> getUserFileByFilePath(String filePath, Long userId, Long currentPage, Long pageCount) {
        Long beginCount = (currentPage - 1) * pageCount;
        UserFile userfile = new UserFile();
        userfile.setUserId(userId);
        userfile.setFilePath(filePath);
        List<UserfileListVO> fileList = userfileMapper.userfileList(userfile, beginCount, pageCount);
        return fileList;
    }

}
```

#### Controller 层代码编写

在 `FileController.java` 接口中新增获取文件接口 `getUserfileList`，代码如下：

```java
import java.util.HashMap;
import java.util.Map;
import com.shiyanlou.file.vo.UserfileListVO;
import com.shiyanlou.file.dto.UserfileListDTO;

@Tag(name = "file", description = "该接口为文件接口，主要用来做一些文件的基本操作，如创建目录，删除，移动，复制等。")
@RestController
@Slf4j
@RequestMapping("/file")
public class FileController {
    ...
    @Operation(summary = "获取文件列表", description = "用来做前台文件列表展示", tags = { "file" })
    @GetMapping(value = "/getfilelist")
    @ResponseBody
    public RestResult<UserfileListVO> getUserfileList(UserfileListDTO userfileListDto,
            @RequestHeader("token") String token) {


        User sessionUser = userService.getUserByToken(token);
        if (sessionUser == null) {
            return RestResult.fail().message("token验证失败");

        }

        List<UserfileListVO> fileList = userfileService.getUserFileByFilePath(userfileListDto.getFilePath(),
                sessionUser.getUserId(), userfileListDto.getCurrentPage(), userfileListDto.getPageCount());

        LambdaQueryWrapper<UserFile> userFileLambdaQueryWrapper = new LambdaQueryWrapper<>();
        userFileLambdaQueryWrapper.eq(UserFile::getUserId, sessionUser.getUserId()).eq(UserFile::getFilePath, userfileListDto.getFilePath());
        int total = userfileService.count(userFileLambdaQueryWrapper);

        Map<String, Object> map = new HashMap<>();
        map.put("total", total);
        map.put("list", fileList);

        return RestResult.success().data(map);

    }
}
```

### 文件分类查询接口开发



创建 `com.shiyanlou.file.constant` 包，并在该包下新建 `FileConstant.java` 类，用来存放常量类，首先在该类中先初始化好文件分类的常量，代码如下：

```java
package com.shiyanlou.file.constant;

public class FileConstant {
    public static final String[] IMG_FILE = {"bmp", "jpg", "png", "tif", "gif", "jpeg"};
    public static final String[] DOC_FILE = {"doc", "docx", "ppt", "pptx", "xls", "xlsx", "txt", "hlp", "wps", "rtf", "html", "pdf"};
    public static final String[] VIDEO_FILE = {"avi", "mp4", "mpg", "mov", "swf"};
    public static final String[] MUSIC_FILE = {"wav", "aif", "au", "mp3", "ram", "wma", "mmf", "amr", "aac", "flac"};
    public static final int IMAGE_TYPE = 1;
    public static final int DOC_TYPE = 2;
    public static final int VIDEO_TYPE = 3;
    public static final int MUSIC_TYPE = 4;
    public static final int OTHER_TYPE = 5;
}
```

#### DAO 层代码编写

上面我们将常用的文件格式按照后缀分为 4 类，分别是图像类，文档类，视频类，音乐类，除了这 4 类的格式，其他格式我们统一放到其他类中，这样当做查询的时侯，查询具体某一类的文件，只需要传入对应的文件格式数组即可，查询其他类，则需要排除这些类，接下来我们首先来实现 sql，向 `UserfileMapper.xml` 文件中添加如下代码：

```xml
<sql id="selectByExtendName" >
    left join file on file.fileId = userfile.fileId
    where extendName in
    <foreach collection="fileNameList" open="(" close=")" separator="," item="fileName" >
        #{fileName}
    </foreach>
    and userId = #{userId}
</sql>
<sql id="selectByNotExtendName">
    left join file on file.fileId = userfile.fileId
    where extendName not in
    <foreach collection="fileNameList" open="(" close=")" separator="," item="fileName" >
        #{fileName}
    </foreach>
    and userId = #{userId}
</sql>
<select id="selectFileByExtendName" parameterType="com.shiyanlou.file.model.UserFile" resultType="com.shiyanlou.file.vo.UserfileListVO">
    select * from userfile
    <include refid="selectByExtendName"></include>
    limit #{beginCount}, #{pageCount}
</select>

<select id="selectCountByExtendName" parameterType="com.shiyanlou.file.model.UserFile" resultType="java.lang.Long">
    select count(*) from userfile
    <include refid="selectByExtendName"></include>
</select>

<select id="selectFileNotInExtendNames" parameterType="com.shiyanlou.file.model.UserFile" resultType="com.shiyanlou.file.vo.UserfileListVO">
    select * from userfile
    <include refid="selectByNotExtendName"></include>
    limit #{beginCount}, #{pageCount}
</select>

<select id="selectCountNotInExtendNames" parameterType="com.shiyanlou.file.model.UserFile" resultType="java.lang.Long">
    select count(*) from userfile
    <include refid="selectByNotExtendName"></include>
</select>
```

上面写了 4 个 sql，接下来在 `UserfileMapper.java` 中新增对应的 Mapper 接口，代码如下：

```java
List<UserfileListVO> selectFileByExtendName(List<String> fileNameList, Long beginCount, Long pageCount, long userId);
Long selectCountByExtendName(List<String> fileNameList, Long beginCount, Long pageCount, long userId);
List<UserfileListVO> selectFileNotInExtendNames(List<String> fileNameList, Long beginCount, Long pageCount, long userId);
Long selectCountNotInExtendNames(List<String> fileNameList, Long beginCount, Long pageCount, long userId);
```

#### Service 层代码编写

在 `UserfileService.java` 接口中，创建通过类型获取用户文件列表接口，代码如下：

```java
...
import java.util.Map;
public interface UserfileService extends IService<Userfile> {
    ...

    Map<String, Object> getUserFileByType(int fileType, Long currentPage, Long pageCount, Long userId);
}
```

向 `UserfileServiceImpl.java` 文件中补充如下代码：

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import com.shiyanlou.file.constant.FileConstant;

@Service
public class UserfileServiceImpl extends ServiceImpl<UserfileMapper, UserFile> implements UserfileService {
    ...
    @Override
    public Map<String, Object> getUserFileByType(int fileType, Long currentPage, Long pageCount, Long userId) {
        Long beginCount = (currentPage - 1) * pageCount;
        List<UserfileListVO> fileList;
        Long total;
        if (fileType == FileConstant.OTHER_TYPE) {

            List<String> arrList = new ArrayList<>();
            arrList.addAll(Arrays.asList(FileConstant.DOC_FILE));
            arrList.addAll(Arrays.asList(FileConstant.IMG_FILE));
            arrList.addAll(Arrays.asList(FileConstant.VIDEO_FILE));
            arrList.addAll(Arrays.asList(FileConstant.MUSIC_FILE));

            fileList = userfileMapper.selectFileNotInExtendNames(arrList,beginCount, pageCount, userId);
            total = userfileMapper.selectCountNotInExtendNames(arrList,beginCount, pageCount, userId);
        } else {
            List<String> fileExtends = null;
            if (fileType == FileConstant.IMAGE_TYPE) {
                fileExtends = Arrays.asList(FileConstant.IMG_FILE);
            } else if (fileType == FileConstant.DOC_TYPE) {
                fileExtends = Arrays.asList(FileConstant.DOC_FILE);
            } else if (fileType == FileConstant.VIDEO_TYPE) {
                fileExtends = Arrays.asList(FileConstant.VIDEO_FILE);
            } else if (fileType == FileConstant.MUSIC_TYPE) {
                fileExtends = Arrays.asList(FileConstant.MUSIC_FILE);
            }
            fileList = userfileMapper.selectFileByExtendName(fileExtends, beginCount, pageCount,userId);
            total = userfileMapper.selectCountByExtendName(fileExtends, beginCount, pageCount,userId);
        }
        Map<String, Object> map = new HashMap<>();
        map.put("list",fileList);
        map.put("total", total);
        return map;
    }
}
```

#### Controller 层代码编写

向 `FileController.java` 文件中补充如下代码：

```java
@Operation(summary = "通过文件类型选择文件", description = "该接口可以实现文件格式分类查看", tags = {"file"})
@GetMapping(value = "/selectfilebyfiletype")
@ResponseBody
public RestResult<List<Map<String, Object>>> selectFileByFileType(int fileType, Long currentPage, Long pageCount, @RequestHeader("token") String token) {

    User sessionUser = userService.getUserByToken(token);
    if (sessionUser == null) {
        return RestResult.fail().message("token验证失败");
    }
    long userId = sessionUser.getUserId();

    Map<String, Object> map = userfileService.getUserFileByType(fileType, currentPage, pageCount, userId);
    return RestResult.success().data(map);

}
```

### 引入依赖



下面引入两个依赖，分别是 `commons-io` 和 `thumbnailator` 在 commons-io 中封装了很多对输入输出流的操作，这在后面的开发过程中需要用到，`thumbnailator` 是一个用来生成图像缩略图的 Java 类库，通过很简单的代码即可生成图片缩略图，也可直接对一整个目录的图片生成缩略图，向 `pom.xml` 文件中添加如下代码：

```xml
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.8.0</version>
</dependency>
<dependency>
    <groupId>net.coobird</groupId>
    <artifactId>thumbnailator</artifactId>
    <version>0.4.13</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.75</version>
</dependency>
```

### 配置文件



Spring Boot 默认会限制文件上传文件大小 2M，超过该大小的文件都会上传失败，因此需要在配置文件中修改该限制，向 `application.properties` 文件中补充如下代码：

```java
#上传下载
spring.servlet.multipart.max-file-size=100MB
spring.servlet.multipart.max-request-size=100MB
spring.servlet.multipart.enabled=true

#文件存储类型
file.storage-type=0
```

### 创建统一异常类



#### 文件 md5 校验失败异常

在 `com.shiyanlou.file` 包下创建 `exception` 文件夹，并在该文件夹下创建 `NotSameFileExpection.java` 文件，写入如下代码：

```java
package com.shiyanlou.file.exception;

public class NotSameFileExpection extends Exception {
    public NotSameFileExpection() {
        super("File MD5 Different");
    }
}
```

#### 上传异常

在 `com.shiyanlou.file.exception` 包下创建 `UploadException.java` 文件，向其中写入如下代码：

```java
package com.shiyanlou.file.exception;

public class UploadException extends RuntimeException {
    public UploadException(Throwable cause) {
        super("上传出现了异常", cause);
    }

    public UploadException(String message) {
        super(message);
    }

    public UploadException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### 创建常用工具类



#### 获取配置文件类

在 Spring Boot 中，有多种方式可以轻松获取到 application.properties 配置文件中的配置参数，但提供的默认都是基于 Spring 体系，当我们在静态工具类中想要获取配置参数，则需要使用如下方式进行获取：

在 `com.shiyanlou.file.config` 包下新建 `PropertiesConfig.java` 类，用来读取环境变量：

```java
package com.shiyanlou.file.config;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;

import com.shiyanlou.file.util.PropertiesUtil;

import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;

@Configuration
public class PropertiesConfig {

    @Resource
    private Environment env;

    @PostConstruct
    public void setProperties() {
        PropertiesUtil.setEnvironment(env);
    }

}
```

在 `com.shiyanlou.file.util` 包下，创建 `PropertiesUtil.java`，通过该类的 `getProperty` 方法，可以获取 `application.properties` 中的配置，代码如下：

```java
package com.shiyanlou.file.util;

import org.springframework.core.env.Environment;

public class PropertiesUtil {
    private static Environment env = null;

    public static void setEnvironment(Environment env) {
        PropertiesUtil.env = env;
    }

    public static String getProperty(String key) {
        return PropertiesUtil.env.getProperty(key);
    }

}
```

#### 文件工具类

在 `com.shiyanlou.file.util` 包下创建 `FileUtil.java` 类，该类用来定义文件的一些常用操作方法，代码如下：

```java
package com.shiyanlou.file.util;

public class FileUtil {
    public static final String[] IMG_FILE = {"bmp", "jpg", "png", "tif", "gif", "jpeg"};
    public static final String[] DOC_FILE = {"doc", "docx", "ppt", "pptx", "xls", "xlsx", "txt", "hlp", "wps", "rtf", "html", "pdf"};
    public static final String[] VIDEO_FILE = {"avi", "mp4", "mpg", "mov", "swf"};
    public static final String[] MUSIC_FILE = {"wav", "aif", "au", "mp3", "ram", "wma", "mmf", "amr", "aac", "flac"};
    public static final int IMAGE_TYPE = 1;
    public static final int DOC_TYPE = 2;
    public static final int VIDEO_TYPE = 3;
    public static final int MUSIC_TYPE = 4;
    public static final int OTHER_TYPE = 5;
    public static final int SHARE_FILE = 6;
    public static final int RECYCLE_FILE = 7;
    /**
     * 判断是否为图片文件
     *
     * @param extendName 文件扩展名
     * @return 是否为图片文件
     */
    public static boolean isImageFile(String extendName) {
        for (int i = 0; i < IMG_FILE.length; i++) {
            if (extendName.equalsIgnoreCase(IMG_FILE[i])) {
                return true;
            }
        }
        return false;
    }
    /**
     * 获取文件扩展名，如果没有扩展名，则返回空串
     * @param fileName 文件名
     * @return 文件扩展名
     */
    public static String getFileExtendName(String fileName) {
        if (fileName.lastIndexOf(".") == -1) {
            return "";
        }
        return fileName.substring(fileName.lastIndexOf(".") + 1);
    }

    /**
     * 获取不包含扩展名的文件名
     *
     * @param fileName 文件名
     * @return 文件名（不带扩展名）
     */
    public static String getFileNameNotExtend(String fileName) {
        String fileType = getFileExtendName(fileName);
        return fileName.replace("." + fileType, "");
    }
}
```

#### 路径工具类

在 `com.shiyanlou.file.util` 包下创建 `PathUtil.java` 类，该类用来获取文件路径，代码如下：

```java
package com.shiyanlou.file.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.apache.commons.lang3.StringUtils;
import org.springframework.util.ResourceUtils;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class PathUtil {

    public static String getFilePath() {

        String path = "upload";
        SimpleDateFormat formater = new SimpleDateFormat("yyyyMMdd");
        path = File.separator + path + File.separator + formater.format(new Date());

        String staticPath = PathUtil.getStaticPath();

        File dir = new File(staticPath + path);
        if (!dir.exists()) {
            try {
                boolean isSuccessMakeDir = dir.mkdirs();
                if (!isSuccessMakeDir) {
                    log.error("目录创建失败:" + PathUtil.getStaticPath() + path);
                }
            } catch (Exception e) {
                log.error("目录创建失败" + PathUtil.getStaticPath() + path);
                return "";
            }
        }
        return path;
    }

    public static String getStaticPath() {
        String localStoragePath = PropertiesUtil.getProperty("file.local-storage-path");
        if (StringUtils.isNotEmpty(localStoragePath)) {
            return localStoragePath;
        }else {
            String projectRootAbsolutePath = getProjectRootPath();

            int index = projectRootAbsolutePath.indexOf("file:");
            if (index != -1) {
                projectRootAbsolutePath = projectRootAbsolutePath.substring(0, index);
            }

            return projectRootAbsolutePath + "static" + File.separator;
        }


    }

    /**
     * 路径解码
     * @param url
     * @return
     */
    public static String urlDecode(String url){
        String decodeUrl = null;
        try {
            decodeUrl = URLDecoder.decode(url, "utf-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return  decodeUrl;
    }

    /**
     * 获取项目所在的根目录路径 resources路径
     * @return
     */
    public static String getProjectRootPath() {
        String absolutePath = null;
        try {
            String url = ResourceUtils.getURL("classpath:").getPath();
            absolutePath = urlDecode(new File(url).getAbsolutePath()) + File.separator;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        return absolutePath;
    }

}
```

### 文件操作



下面通过代码来讲解如何对文件进行上传和下载，文件的存储形式有多种，我们可以选择将文件存储在本地，阿里云 OSS，七牛云或者 FastDFS 等等，可以说存储的方式有很多种，这里我们只实现其中的一种，但是为了以后便于扩展，我们需要通过抽象工厂的设计模式来对代码结构进行设计，这样做的好处就是能保证我们写的代码易于扩展，且对之前的代码没有影响。

### 抽象工厂模式类图



![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/a61ef206557119979d85aec3f993c904-0)

如上图，是我对整个文件操作的一个类图设计，最上层封装了三个具体的操作，分别是上传，下载和删除，然后第二层是对抽象接口的一个实现，因为目前我们只实现本地文件的操作，因此这里的实现类只有一个，如果后续有其他方式存储方式，可以继续横向扩展其实现类，再下面分别是抽象工厂和具体的工厂，主要是为了提供给外部来使用，整体的规划就是这样，接下来是对代码的实现。



### 文件上传



前端上传文件时如果文件很大，上传时会出现各种问题，比如连接超时了，网断了，都会导致上传失败。为了避免上传大文件时上传超时，就需要用到切片上传，工作原理是：我们将大文件切割为小文件，然后将切割的若干小文件上传到服务器端，服务器端接收到被切割的小文件，然后按照一定的顺序将小文件拼接合并成一个大文件。

#### 抽象类接口

创建 `com.shiyanlou.file.operation.upload` 包，并在该包下创建 `Uploader.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.upload;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import com.shiyanlou.file.operation.upload.domain.UploadFile;
import com.shiyanlou.file.util.PathUtil;

import org.apache.commons.io.FileUtils;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class Uploader {
    public static final String ROOT_PATH = "upload";
    public static final String FILE_SEPARATOR = "/";
    // 文件大小限制，单位KB
    public final int maxSize = 10000000;

    public abstract List<UploadFile> upload(HttpServletRequest request, UploadFile uploadFile);

    /**
     * 根据字符串创建本地目录 并按照日期建立子目录返回
     *
     * @return
     */
    protected String getSaveFilePath() {

        String path = ROOT_PATH;
        SimpleDateFormat formater = new SimpleDateFormat("yyyyMMdd");
        path = FILE_SEPARATOR + path + FILE_SEPARATOR + formater.format(new Date());

        String staticPath = PathUtil.getStaticPath();

        File dir = new File(staticPath + path);
        //LOG.error(PathUtil.getStaticPath() + path);
        if (!dir.exists()) {
            try {
                boolean isSuccessMakeDir = dir.mkdirs();
                if (!isSuccessMakeDir) {
                    log.error("目录创建失败:" + PathUtil.getStaticPath() + path);
                }
            } catch (Exception e) {
                log.error("目录创建失败" + PathUtil.getStaticPath() + path);
                return "";
            }
        }
        return path;
    }

    /**
     * 依据原始文件名生成新文件名
     *
     * @return
     */
    protected String getTimeStampName() {
        try {
            SecureRandom number = SecureRandom.getInstance("SHA1PRNG");
            return "" + number.nextInt(10000)
                    + System.currentTimeMillis();
        } catch (NoSuchAlgorithmException e) {
            log.error("生成安全随机数失败");
        }
        return ""
                + System.currentTimeMillis();

    }

    public synchronized boolean checkUploadStatus(UploadFile param, File confFile) throws IOException {
        RandomAccessFile confAccessFile = new RandomAccessFile(confFile, "rw");
        //设置文件长度
        confAccessFile.setLength(param.getTotalChunks());
        //设置起始偏移量
        confAccessFile.seek(param.getChunkNumber() - 1);
        //将指定的一个字节写入文件中 127，
        confAccessFile.write(Byte.MAX_VALUE);
        byte[] completeStatusList = FileUtils.readFileToByteArray(confFile);
        confAccessFile.close();//不关闭会造成无法占用
        //创建conf文件文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认的0,已上传的就是127
        for (int i = 0; i < completeStatusList.length; i++) {
            if (completeStatusList[i] != Byte.MAX_VALUE) {
                return false;
            }
        }
        confFile.delete();
        return true;
    }

    protected String getFileName(String fileName){
        if (!fileName.contains(".")) {
            return fileName;
        }
        return fileName.substring(0, fileName.lastIndexOf("."));
    }
}
```

#### 本地上传实现类

创建 `com.shiyanlou.file.operation.upload.product` 包，该包用于存放各种方式上传实现，目前我们暂时只实现本地文件上传方式，在该包下创建 `LocalStorageUploader.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.operation.upload.product;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import com.shiyanlou.file.exception.NotSameFileExpection;
import com.shiyanlou.file.exception.UploadException;
import com.shiyanlou.file.operation.upload.Uploader;
import com.shiyanlou.file.operation.upload.domain.UploadFile;
import com.shiyanlou.file.util.FileUtil;
import com.shiyanlou.file.util.PathUtil;

import org.apache.commons.lang3.StringUtils;
import org.apache.tomcat.util.http.fileupload.servlet.ServletFileUpload;
import org.springframework.stereotype.Component;
import org.springframework.util.DigestUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.support.StandardMultipartHttpServletRequest;

import lombok.extern.slf4j.Slf4j;
import net.coobird.thumbnailator.Thumbnails;

@Component
public class LocalStorageUploader extends Uploader{

    public LocalStorageUploader() {

    }

    @Override
    public List<UploadFile> upload(HttpServletRequest httpServletRequest,UploadFile uploadFile) {
        List<UploadFile> saveUploadFileList = new ArrayList<UploadFile>();
        StandardMultipartHttpServletRequest standardMultipartHttpServletRequest = (StandardMultipartHttpServletRequest) httpServletRequest;
        boolean isMultipart = ServletFileUpload.isMultipartContent(standardMultipartHttpServletRequest);
        if (!isMultipart) {
            throw new UploadException("未包含文件上传域");
        }

        String savePath = getSaveFilePath();

        try {
            Iterator<String> iter = standardMultipartHttpServletRequest.getFileNames();
            while (iter.hasNext()) {
                saveUploadFileList = doUpload(standardMultipartHttpServletRequest, savePath, iter, uploadFile);
            }
        } catch (IOException e) {
            throw new UploadException("未包含文件上传域");
        } catch (NotSameFileExpection notSameFileExpection) {
            notSameFileExpection.printStackTrace();
        }
        return saveUploadFileList;
    }

    private List<UploadFile> doUpload(StandardMultipartHttpServletRequest standardMultipartHttpServletRequest, String savePath, Iterator<String> iter, UploadFile uploadFile) throws IOException, NotSameFileExpection {
        List<UploadFile> saveUploadFileList = new ArrayList<UploadFile>();
        MultipartFile multipartfile = standardMultipartHttpServletRequest.getFile(iter.next());

        String timeStampName = uploadFile.getIdentifier();

        String originalName = multipartfile.getOriginalFilename();

        String fileName = getFileName(originalName);
        String fileType = FileUtil.getFileExtendName(originalName);
        uploadFile.setFileName(fileName);
        uploadFile.setFileType(fileType);
        uploadFile.setTimeStampName(timeStampName);

        String saveFilePath = savePath + FILE_SEPARATOR + timeStampName + "." + fileType;
        String tempFilePath = savePath + FILE_SEPARATOR + timeStampName + "." + fileType + "_tmp";
        String minFilePath = savePath + FILE_SEPARATOR + timeStampName + "_min" + "." + fileType;
        String confFilePath = savePath + FILE_SEPARATOR + timeStampName + "." + "conf";
        File file = new File(PathUtil.getStaticPath() + FILE_SEPARATOR + saveFilePath);
        File tempFile = new File(PathUtil.getStaticPath() + FILE_SEPARATOR + tempFilePath);
        File minFile = new File(PathUtil.getStaticPath() + FILE_SEPARATOR + minFilePath);
        File confFile = new File(PathUtil.getStaticPath() + FILE_SEPARATOR + confFilePath);
        // uploadFile.setIsOSS(0);
        // uploadFile.setStorageType(0);
        uploadFile.setUrl(saveFilePath);

        if (StringUtils.isEmpty(uploadFile.getTaskId())) {
            uploadFile.setTaskId(UUID.randomUUID().toString());
        }

        //第一步 打开将要写入的文件
        RandomAccessFile raf = new RandomAccessFile(tempFile, "rw");
        //第二步 打开通道
        FileChannel fileChannel = raf.getChannel();
        //第三步 计算偏移量
        long position = (uploadFile.getChunkNumber() - 1) * uploadFile.getChunkSize();
        //第四步 获取分片数据
        byte[] fileData = multipartfile.getBytes();
        //第五步 写入数据
        fileChannel.position(position);
        fileChannel.write(ByteBuffer.wrap(fileData));
        fileChannel.force(true);
        fileChannel.close();
        raf.close();
        //判断是否完成文件的传输并进行校验与重命名
        boolean isComplete = checkUploadStatus(uploadFile, confFile);
        if (isComplete) {
            FileInputStream fileInputStream = new FileInputStream(tempFile.getPath());
            String md5 = DigestUtils.md5DigestAsHex(fileInputStream);
            fileInputStream.close();
            if (StringUtils.isNotBlank(md5) && !md5.equals(uploadFile.getIdentifier())) {
                throw new NotSameFileExpection();
            }
            tempFile.renameTo(file);
            if (FileUtil.isImageFile(uploadFile.getFileType())){
                Thumbnails.of(file).size(300, 300).toFile(minFile);
            }

            uploadFile.setSuccess(1);
            uploadFile.setMessage("上传成功");
        } else {
            uploadFile.setSuccess(0);
            uploadFile.setMessage("未完成");
        }
        uploadFile.setFileSize(uploadFile.getTotalSize());
        saveUploadFileList.add(uploadFile);

        return saveUploadFileList;
    }
}
```

#### 本地上传文件实体类

创建 `com.shiyanlou.file.operation.upload.domain` 包，在该包下创建 `UploadFile.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.operation.upload.domain;

import lombok.Data;

@Data
public class UploadFile {
    private String fileName;
    private String fileType;
    private long fileSize;
    private String timeStampName;
    private int success;
    private String message;
    private String url;
    //切片上传相关参数
    private String taskId;
    private int chunkNumber;
    private long chunkSize;
    private int totalChunks;
    private String identifier;
    private long totalSize;
    private long currentChunkSize;

}
```

### 文件下载



#### 抽象类接口

创建 `com.shiyanlou.file.operation.download` 包，并创建 `Downloader.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.download;

import javax.servlet.http.HttpServletResponse;

import com.shiyanlou.file.operation.download.domain.DownloadFile;

public abstract class Downloader {
    public abstract void download(HttpServletResponse httpServletResponse, DownloadFile uploadFile);
}
```

#### 本地下载实现类

创建 `com.shiyanlou.file.operation.download.product` 包，该包用于存放各种方式下载实现，目前我们暂时只实现本地文件下载方式，并创建 `LocalStorageDownloader.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.download.product;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;

import javax.servlet.http.HttpServletResponse;

import com.shiyanlou.file.operation.download.Downloader;
import com.shiyanlou.file.operation.download.domain.DownloadFile;
import com.shiyanlou.file.util.PathUtil;

import org.springframework.stereotype.Component;

@Component
public class LocalStorageDownloader extends Downloader {
    @Override
    public void download(HttpServletResponse httpServletResponse, DownloadFile downloadFile) {
        BufferedInputStream bis = null;
        byte[] buffer = new byte[1024];
        //设置文件路径
        File file = new File(PathUtil.getStaticPath() + downloadFile.getFileUrl());
        if (file.exists()) {

            FileInputStream fis = null;

            try {
                fis = new FileInputStream(file);
                bis = new BufferedInputStream(fis);
                OutputStream os = httpServletResponse.getOutputStream();
                int i = bis.read(buffer);
                while (i != -1) {
                    os.write(buffer, 0, i);
                    i = bis.read(buffer);
                }

            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (bis != null) {
                    try {
                        bis.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```

#### 本地下载文件实体类

创建 `com.shiyanlou.file.operation.download.domain` 包，并创建本地下载文件实体类 `DownloadFile.java`，代码如下：

```java
package com.shiyanlou.file.operation.download.domain;

import lombok.Data;

@Data
public class DownloadFile {
    private String fileUrl;
    private String timeStampName;
}
```

### 文件删除



#### 抽象类接口

创建 `com.shiyanlou.file.operation.delete` 包，并在该包下创建 `Deleter.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.delete;

public abstract class Deleter {
    public abstract void delete(DeleteFile deleteFile);
}
```

#### 本地删除实现类

创建 `com.shiyanlou.file.operation.delete.product` 包，该包用于存放各种方式删除实现，目前我们暂时只实现本地文件删除方式，并在该包下创建 `LocalStorageDeleter.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.delete.product;

import java.io.File;

import com.shiyanlou.file.operation.delete.Deleter;
import com.shiyanlou.file.operation.delete.domain.DeleteFile;
import com.shiyanlou.file.util.FileUtil;
import com.shiyanlou.file.util.PathUtil;

import org.springframework.stereotype.Component;

@Component
public class LocalStorageDeleter extends Deleter {
    @Override
    public void delete(DeleteFile deleteFile) {
        File file = new File(PathUtil.getStaticPath() + deleteFile.getFileUrl());
        if (file.exists()) {
            file.delete();
        }

        if (FileUtil.isImageFile(FileUtil.getFileExtendName(deleteFile.getFileUrl()))) {
            File minFile = new File(PathUtil.getStaticPath() + deleteFile.getFileUrl().replace(deleteFile.getTimeStampName(), deleteFile.getTimeStampName() + "_min"));
            if (minFile.exists()) {
                minFile.delete();
            }
        }
    }
}
```

#### 删除文件实体类

创建 `com.shiyanlou.file.operation.delete.domain` 包，并创建删除文件实体类 `DeleteFile.java`，代码如下：

```java
package com.shiyanlou.file.operation.delete.domain;

import lombok.Data;

@Data
public class DeleteFile {
    private String fileUrl;
    private String timeStampName;
}
```

### 创建文件操作工厂



#### 抽象工厂

在 `com.shiyanlou.file.operation` 包下创建类 `FileOperationFactory.java`，代码如下：

```java
package com.shiyanlou.file.operation;

import com.shiyanlou.file.operation.delete.Deleter;
import com.shiyanlou.file.operation.download.Downloader;
import com.shiyanlou.file.operation.upload.Uploader;

public interface FileOperationFactory {
    Uploader getUploader();
    Downloader getDownloader();
    Deleter getDeleter();
}
```

#### 具体工厂

在 `com.shiyanlou.file.operation` 包下创建类 `LocalStorageOperationFactory.java`，代码如下：

```java
package com.shiyanlou.file.operation;

import javax.annotation.Resource;

import com.shiyanlou.file.operation.delete.Deleter;
import com.shiyanlou.file.operation.delete.product.LocalStorageDeleter;
import com.shiyanlou.file.operation.download.Downloader;
import com.shiyanlou.file.operation.download.product.LocalStorageDownloader;
import com.shiyanlou.file.operation.upload.Uploader;
import com.shiyanlou.file.operation.upload.product.LocalStorageUploader;

import org.springframework.stereotype.Component;

@Component
public class LocalStorageOperationFactory implements FileOperationFactory{

    @Resource
    LocalStorageUploader localStorageUploader;
    @Resource
    LocalStorageDownloader localStorageDownloader;
    @Resource
    LocalStorageDeleter localStorageDeleter;
    @Override
    public Uploader getUploader() {
        return localStorageUploader;
    }

    @Override
    public Downloader getDownloader() {
        return localStorageDownloader;
    }

    @Override
    public Deleter getDeleter() {
        return localStorageDeleter;
    }


}
```

### 上传下载接口实现



#### 上传下载文件 DTO

在 `com.shiyanlou.file.dto` 包下创建上传文件 DTO `UploadFileDTO.java`，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "上传文件DTO",required = true)
public class UploadFileDTO {

    @Schema(description = "文件路径")
    private String filePath;

    @Schema(description = "上传时间")
    private String uploadTime;

    @Schema(description = "扩展名")
    private String extendName;


    @Schema(description = "文件名")
    private String filename;

    @Schema(description = "文件大小")
    private Long fileSize;

    @Schema(description = "切片数量")
    private int chunkNumber;

    @Schema(description = "切片大小")
    private long chunkSize;

    @Schema(description = "所有切片")
    private int totalChunks;
    @Schema(description = "总大小")
    private long totalSize;
    @Schema(description = "当前切片大小")
    private long currentChunkSize;
    @Schema(description = "md5码")
    private String identifier;

}
```

在 `com.shiyanlou.file.dto` 包下创建下载文件 DTO `DownloadFileDTO.java`，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "下载文件DTO",required = true)
public class DownloadFileDTO {
    private Long userFileId;
}
```

#### 上传文件 VO

在 `com.shiyanlou.file.vo` 包下创建上传文件 VO `UploadFileVo.java`，代码如下：

```java
package com.shiyanlou.file.vo;

import java.util.List;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "文件上传Vo",required = true)
public class UploadFileVo {

    @Schema(description = "时间戳", example = "123123123123")
    private String timeStampName;
    @Schema(description = "跳过上传", example = "true")
    private boolean skipUpload;
    @Schema(description = "是否需要合并分片", example = "true")
    private boolean needMerge;
    @Schema(description = "已经上传的分片", example = "[1,2,3]")
    private List<Integer> uploaded;


}
```

### 文件上传下载 Service 层代码



#### Service 接口层代码实现

在 `com.shiyanlou.file.service` 包下创建 `FiletransferService.java` 类，代码如下：

```java
package com.shiyanlou.file.service;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.shiyanlou.file.dto.DownloadFileDTO;
import com.shiyanlou.file.dto.UploadFileDTO;

public interface FiletransferService {
    void uploadFile(HttpServletRequest request, UploadFileDTO uploadFileDto, Long userId);
    void downloadFile(HttpServletResponse httpServletResponse, DownloadFileDTO downloadFileDTO);
}
```

#### Service 实现层代码实现

在 `com.shiyanlou.file.service.impl` 包下创建 `FiletransferServiceImpl.java` 类，代码如下：

```java
package com.shiyanlou.file.service.impl;

import java.io.UnsupportedEncodingException;
import java.util.List;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.shiyanlou.file.dto.DownloadFileDTO;
import com.shiyanlou.file.dto.UploadFileDTO;
import com.shiyanlou.file.mapper.FileMapper;
import com.shiyanlou.file.mapper.UserfileMapper;
import com.shiyanlou.file.model.File;
import com.shiyanlou.file.model.UserFile;
import com.shiyanlou.file.operation.FileOperationFactory;
import com.shiyanlou.file.operation.download.Downloader;
import com.shiyanlou.file.operation.download.domain.DownloadFile;
import com.shiyanlou.file.operation.upload.Uploader;
import com.shiyanlou.file.operation.upload.domain.UploadFile;
import com.shiyanlou.file.service.FiletransferService;
import com.shiyanlou.file.util.DateUtil;
import com.shiyanlou.file.util.PropertiesUtil;

import org.springframework.stereotype.Service;

@Service
public class FiletransferServiceImpl implements FiletransferService{

    @Resource
    FileMapper fileMapper;
    @Resource
    UserfileMapper userfileMapper;

    @Resource
    FileOperationFactory localStorageOperationFactory;

    @Override
    public void uploadFile(HttpServletRequest request, UploadFileDTO uploadFileDto, Long userId) {

        Uploader uploader = null;
        UploadFile uploadFile = new UploadFile();
        uploadFile.setChunkNumber(uploadFileDto.getChunkNumber());
        uploadFile.setChunkSize(uploadFileDto.getChunkSize());
        uploadFile.setTotalChunks(uploadFileDto.getTotalChunks());
        uploadFile.setIdentifier(uploadFileDto.getIdentifier());
        uploadFile.setTotalSize(uploadFileDto.getTotalSize());
        uploadFile.setCurrentChunkSize(uploadFileDto.getCurrentChunkSize());
        String storageType = PropertiesUtil.getProperty("file.storage-type");
        synchronized (FiletransferService.class) {
            if ("0".equals(storageType)) {
                uploader = localStorageOperationFactory.getUploader();
            }
        }

        List<UploadFile> uploadFileList = uploader.upload(request, uploadFile);
        for (int i = 0; i < uploadFileList.size(); i++){
            uploadFile = uploadFileList.get(i);
            File file = new File();

            file.setIdentifier(uploadFileDto.getIdentifier());
            file.setStorageType(Integer.parseInt(storageType));
            file.setTimeStampName(uploadFile.getTimeStampName());
            if (uploadFile.getSuccess() == 1){
                file.setFileUrl(uploadFile.getUrl());
                file.setFileSize(uploadFile.getFileSize());
                file.setPointCount(1);
                fileMapper.insert(file);
                UserFile userFile = new UserFile();
                userFile.setFileId(file.getFileId());
                userFile.setExtendName(uploadFile.getFileType());
                userFile.setFileName(uploadFile.getFileName());
                userFile.setFilePath(uploadFileDto.getFilePath());
                //userFile.setDeleteFlag(0);
                userFile.setUserId(userId);
                userFile.setIsDir(0);
                userFile.setUploadTime(DateUtil.getCurrentTime());
                userfileMapper.insert(userFile);
            }

        }
    }

    @Override
    public void downloadFile(HttpServletResponse httpServletResponse, DownloadFileDTO downloadFileDTO) {
        UserFile userFile = userfileMapper.selectById(downloadFileDTO.getUserFileId());

        String fileName = userFile.getFileName() + "." + userFile.getExtendName();
        try {
            fileName = new String(fileName.getBytes("utf-8"), "ISO-8859-1");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        httpServletResponse.setContentType("application/force-download");// 设置强制下载不打开
        httpServletResponse.addHeader("Content-Disposition", "attachment;fileName=" + fileName);// 设置文件名


        File file = fileMapper.selectById(userFile.getFileId());
        Downloader downloader = null;
        if (file.getStorageType() == 0) {
            downloader = localStorageOperationFactory.getDownloader();
        }
        DownloadFile uploadFile = new DownloadFile();
        uploadFile.setFileUrl(file.getFileUrl());
        uploadFile.setTimeStampName(file.getTimeStampName());
        downloader.download(httpServletResponse, uploadFile);
    }
}
```

向 `com.shiyanlou.file.model` 包下的 `File.java` 文件中添加下面三个属性，其中：

**storageType** 用来保存文件的存储类型。

**identifier** 保存文件的 md5 唯一标识，这个唯一标识是文件极速秒传的关键，当检测上传文件的 md5 已存在，则文件已存在于服务器，文件直接返回上传成功。

**pointCount** 用来保存文件的引用数量，当上传文件在服务器已存在，则 pointCount 加 1，文件删除的时候减 1，此时如果引用数量大于 0，则文件逻辑删除，等于 0 时文件需要彻底物理删除，代码如下：

```java
    @Column(columnDefinition="int(1) comment '存储类型 0-本地存储, 1-阿里云存储, 2-FastDFS存储'")
    private Integer storageType;

    @Column(columnDefinition="varchar(32) comment 'md5唯一标识'")
    private String identifier;

    @Column(columnDefinition="int(1) comment '引用数量'")
    private Integer pointCount;
```

### 文件传输类接口创建



在 `com.shiyanlou.file.controller` 包下创建 `FiletransferController.java` 类，这个类专门用来作为文件传输接口，主要职责为文件上传，下载及删除，代码如下：

```java
package com.shiyanlou.file.controller;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import com.shiyanlou.file.dto.DownloadFileDTO;
import com.shiyanlou.file.common.RestResult;
import com.shiyanlou.file.dto.UploadFileDTO;
import com.shiyanlou.file.model.File;
import com.shiyanlou.file.model.User;
import com.shiyanlou.file.model.UserFile;
import com.shiyanlou.file.service.FileService;
import com.shiyanlou.file.service.FiletransferService;
import com.shiyanlou.file.service.UserService;
import com.shiyanlou.file.service.UserfileService;
import com.shiyanlou.file.util.DateUtil;
import com.shiyanlou.file.util.FileUtil;
import com.shiyanlou.file.vo.UploadFileVo;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;

@Tag(name = "filetransfer", description = "该接口为文件传输接口，主要用来做文件的上传和下载")
@RestController
@RequestMapping("/filetransfer")
public class FiletransferController {

    @Resource
    UserService userService;
    @Resource
    FileService fileService;
    @Resource
    UserfileService userfileService;
    @Resource
    FiletransferService filetransferService;

    @Operation(summary = "极速上传", description = "校验文件MD5判断文件是否存在，如果存在直接上传成功并返回skipUpload=true，如果不存在返回skipUpload=false需要再次调用该接口的POST方法", tags = {"filetransfer"})
    @GetMapping(value = "/uploadfile")
    @ResponseBody
    public RestResult<UploadFileVo> uploadFileSpeed(UploadFileDTO uploadFileDto, @RequestHeader("token") String token) {

        User sessionUser = userService.getUserByToken(token);
        if (sessionUser == null){

            return RestResult.fail().message("未登录");
        }

        UploadFileVo uploadFileVo = new UploadFileVo();
        Map<String, Object> param = new HashMap<String, Object>();
        param.put("identifier", uploadFileDto.getIdentifier());
        synchronized (FiletransferController.class) {
            List<File> list = fileService.listByMap(param);
            if (list != null && !list.isEmpty()) {
                File file = list.get(0);

                UserFile userfile = new UserFile();
                userfile.setFileId(file.getFileId());
                userfile.setUserId(sessionUser.getUserId());
                userfile.setFilePath(uploadFileDto.getFilePath());
                String fileName = uploadFileDto.getFilename();
                userfile.setFileName(fileName.substring(0, fileName.lastIndexOf(".")));
                userfile.setExtendName(FileUtil.getFileExtendName(fileName));
                userfile.setIsDir(0);
                userfile.setUploadTime(DateUtil.getCurrentTime());
                userfileService.save(userfile);
                // fileService.increaseFilePointCount(file.getFileId());
                uploadFileVo.setSkipUpload(true);

            } else {
                uploadFileVo.setSkipUpload(false);

            }
        }
        return RestResult.success().data(uploadFileVo);

    }

    @Operation(summary = "上传文件", description = "真正的上传文件接口", tags = {"filetransfer"})
    @RequestMapping(value = "/uploadfile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<UploadFileVo> uploadFile(HttpServletRequest request, UploadFileDTO uploadFileDto, @RequestHeader("token") String token) {

        User sessionUser = userService.getUserByToken(token);
        if (sessionUser == null){
            return RestResult.fail().message("未登录");
        }


        filetransferService.uploadFile(request, uploadFileDto, sessionUser.getUserId());
        UploadFileVo uploadFileVo = new UploadFileVo();
        return RestResult.success().data(uploadFileVo);

    }

    @Operation(summary = "下载文件", description = "下载文件接口", tags = {"filetransfer"})
    @RequestMapping(value = "/downloadfile", method = RequestMethod.GET)
    public void downloadFile(HttpServletResponse response, DownloadFileDTO downloadFileDTO) {
        filetransferService.downloadFile(response, downloadFileDTO);
    }
}
```

### 删除文件接口开发



下图为删除文件流程图，整个删除的过程其实只是做标记，并非真正的删除数据和删除磁盘文件，这样做的目的是为了后续回收站功能扩展。

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/ffe14fda1acf0aa7063f58676dbd4d51-0)

### Model 层实体类添加



打开 `com.shiyanlou.file.model` 包，并在该包下添加 `RecoveryFile.java` 类，每次删除文件操作都会记录到该表，用于后续文件恢复使用，代码如下：

```java
package com.shiyanlou.file.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import lombok.Data;

@Data
@Table(name = "recoveryfile")
@Entity
@TableName("recoveryfile")
public class RecoveryFile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @TableId(type = IdType.AUTO)
    @Column(columnDefinition="bigint(20)")
    private Long recoveryFileId;
    @Column(columnDefinition = "bigint(20)")
    private Long userFileId;
    @Column(columnDefinition="varchar(25)")
    private String deleteTime;
    @Column(columnDefinition = "varchar(50)")
    private String deleteBatchNum;
}
```

打开 `com.shiyanlou.file.model` 包，在 `UserFile.java` 实体类中添加三个属性，代码如下：

```java
@Column(columnDefinition="int(11) comment '删除标志 0-未删除 1-已删除'")
private Integer deleteFlag;

@Column(columnDefinition="varchar(25) comment '删除时间'")
private String deleteTime;

@Column(columnDefinition = "varchar(50) comment '删除批次号'")
private String deleteBatchNum;
```

上面增加了删除文件标识 `deleteFlag`，当我们新增文件或者上传文件的时候，应该将该标志置为 0，删除之后置为 1，因此在之前已经实现了的新增文件夹及上传文件的时候，需要给该字段设置为 0，打开 `FileController.java` 类，修改 `createFile` 接口如下：

```java
...
public RestResult<String> createFile(@RequestBody CreateFileDTO createFileDto,
        @RequestHeader("token") String token) {
    ...
    userFile.setIsDir(1);
    userFile.setUploadTime(DateUtil.getCurrentTime());
    //***修改点***，添加下面这一行代码
    userFile.setDeleteFlag(0);
    userfileService.save(userFile);
    return RestResult.success();
}
```

打开 `FiletransferServiceImpl.java` 类，修改 `uploadFile` 接口如下：

```java
...
@Override
public void uploadFile(HttpServletRequest request, UploadFileDTO uploadFileDto, Long userId) {
            ...
            userFile.setFileName(uploadFile.getFileName());
            userFile.setFilePath(uploadFileDto.getFilePath());
            //***修改点***，添加下面这一行代码
            userFile.setDeleteFlag(0);
            userFile.setUserId(userId);
            ...
}
```

打开 `FiletransferController.java` 类，修改 `uploadFileSpeed` 接口如下：

```java
...
public RestResult<UploadFileVo> uploadFileSpeed(UploadFileDTO uploadFileDto, @RequestHeader("token") String token) {
            ...
            userfile.setIsDir(0);
            userfile.setUploadTime(DateUtil.getCurrentTime());
            //***修改点***，添加下面这一行代码
            userfile.setDeleteFlag(0);
            userfileService.save(userfile);
            // fileService.increaseFilePointCount(file.getFileId());
            uploadFileVo.setSkipUpload(true);
            ...
}
```

### DTO 和 VO 实体类



在 `com.shiyanlou.file.dto` 包下创建 `DeleteFileDTO.java`实体类，作为删除文件接口参数，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "删除文件DTO",required = true)
public class DeleteFileDTO {
    @Schema(description = "用户文件id")
    private Long userFileId;
    @Schema(description = "文件路径")
    @Deprecated
    private String filePath;
    @Schema(description = "文件名")
    @Deprecated
    private String fileName;
    @Schema(description = "是否是目录")
    @Deprecated
    private Integer isDir;
}
```

继续在该包下创建 `BatchDeleteFileDTO.java` 实体类，作为批量删除文件接口参数，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "批量删除文件DTO",required = true)
public class BatchDeleteFileDTO {
    @Schema(description="文件集合")
    private String files;
}
```

### Service 层代码开发



打开 `com.shiyanlou.file.service` 包下的 `UserfileService.java` 类，并在该类中添加如下代码：

```java
void deleteUserFile(Long userFileId, Long sessionUserId);
List<UserFile> selectFileTreeListLikeFilePath(String filePath, long userId);
```

打开 `com.shiyanlou.file.service.impl` 包下的 `UserfileServiceImpl` 类，并在该类中添加如下代码实现：

```java
...
import java.util.UUID;
import com.shiyanlou.file.util.DateUtil;
import com.shiyanlou.file.model.File;
import com.shiyanlou.file.model.RecoveryFile;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.shiyanlou.file.mapper.RecoveryFileMapper;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.shiyanlou.file.mapper.FileMapper;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class UserfileServiceImpl extends ServiceImpl<UserfileMapper, Userfile> implements UserfileService {
    public static Executor executor = Executors.newFixedThreadPool(20);
    @Resource
    UserfileMapper userfileMapper;
    @Resource
    FileMapper fileMapper;
    @Resource
    RecoveryFileMapper recoveryFileMapper;
    ...

    @Override
    public void deleteUserFile(Long userFileId, Long sessionUserId) {

        UserFile userFile = userfileMapper.selectById(userFileId);
        String uuid = UUID.randomUUID().toString();
        if (userFile.getIsDir() == 1) {
            LambdaUpdateWrapper<UserFile> userFileLambdaUpdateWrapper = new LambdaUpdateWrapper<UserFile>();
            userFileLambdaUpdateWrapper.set(UserFile::getDeleteFlag, 1)
                    .set(UserFile::getDeleteBatchNum, uuid)
                    .set(UserFile::getDeleteTime, DateUtil.getCurrentTime())
                    .eq(UserFile::getUserFileId, userFileId);
            userfileMapper.update(null, userFileLambdaUpdateWrapper);

            String filePath = userFile.getFilePath() + userFile.getFileName() + "/";
            updateFileDeleteStateByFilePath(filePath, userFile.getDeleteBatchNum(), sessionUserId);

        }else{

            UserFile userFileTemp = userfileMapper.selectById(userFileId);
            File file = fileMapper.selectById(userFileTemp.getFileId());

            LambdaUpdateWrapper<UserFile> userFileLambdaUpdateWrapper = new LambdaUpdateWrapper<>();
            userFileLambdaUpdateWrapper.set(UserFile::getDeleteFlag, 1)
                    .set(UserFile::getDeleteTime, DateUtil.getCurrentTime())
                    .set(UserFile::getDeleteBatchNum, uuid)
                    .eq(UserFile::getUserFileId, userFileTemp.getUserFileId());
            userfileMapper.update(null, userFileLambdaUpdateWrapper);

        }

        RecoveryFile recoveryFile = new RecoveryFile();
        recoveryFile.setUserFileId(userFileId);
        recoveryFile.setDeleteTime(DateUtil.getCurrentTime());
        recoveryFile.setDeleteBatchNum(uuid);
        recoveryFileMapper.insert(recoveryFile);


    }


    @Override
    public List<UserFile> selectFileTreeListLikeFilePath(String filePath, long userId) {
        //UserFile userFile = new UserFile();
        filePath = filePath.replace("\\", "\\\\\\\\");
        filePath = filePath.replace("'", "\\'");
        filePath = filePath.replace("%", "\\%");
        filePath = filePath.replace("_", "\\_");

        //userFile.setFilePath(filePath);

        LambdaQueryWrapper<UserFile> lambdaQueryWrapper = new LambdaQueryWrapper<>();

        log.info("查询文件路径：" + filePath);

        lambdaQueryWrapper.eq(UserFile::getUserId, userId).likeRight(UserFile::getFilePath, filePath);
        return userfileMapper.selectList(lambdaQueryWrapper);
    }

}
```

在 `com.shiyanlou.file.mapper` 包下新建 `RecoveryFileMapper.java` 类，向其中写入如下代码：

```java
package com.shiyanlou.file.mapper;

import java.util.List;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.shiyanlou.file.model.RecoveryFile;
import com.shiyanlou.file.vo.RecoveryFileListVO;

public interface RecoveryFileMapper extends BaseMapper<RecoveryFile> {
    List<RecoveryFileListVO> selectRecoveryFileList();
}
```

在 `com.shiyanlou.file.vo` 包下新建 `RecoveryFileListVO.java` 类，向其中写入如下代码：

```java
package com.shiyanlou.file.vo;

public class RecoveryFileListVO {

}
```

在 `com.shiyanlou.file.service.impl` 包下新建 `RecoveryFileServiceImpl.java` 类，向其中写入如下代码：

```java
package com.shiyanlou.file.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.shiyanlou.file.mapper.RecoveryFileMapper;
import com.shiyanlou.file.model.RecoveryFile;
import com.shiyanlou.file.service.RecoveryFileService;

public class RecoveryFileServiceImpl extends ServiceImpl<RecoveryFileMapper, RecoveryFile>
        implements RecoveryFileService {

}
```

在 `com.shiyanlou.file.service` 包下新建 `RecoveryFileService.java` 类，向其中写入如下代码：

```java
package com.shiyanlou.file.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.shiyanlou.file.model.RecoveryFile;

public interface RecoveryFileService extends IService<RecoveryFile> {

}
```

删除目录时需要将该文件目录下的所有文件都放入回收站，而代码实现则是通过一个删除标志来实现，为了防止文件目录下文件特别多，因此这里需要创建一个新的线程去执行，防止出现阻塞，继续向 `UserfileServiceImpl.java` 类中添加如下代码：

```java
...
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class UserfileServiceImpl extends ServiceImpl<UserfileMapper, Userfile> implements UserfileService {
    ...
    private void updateFileDeleteStateByFilePath(String filePath, String deleteBatchNum, Long userId) {
        new Thread(()->{
            List<UserFile> fileList = selectFileTreeListLikeFilePath(filePath, userId);
            for (int i = 0; i < fileList.size(); i++){
                UserFile userFileTemp = fileList.get(i);
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        //标记删除标志
                        LambdaUpdateWrapper<UserFile> userFileLambdaUpdateWrapper1 = new LambdaUpdateWrapper<>();
                        userFileLambdaUpdateWrapper1.set(UserFile::getDeleteFlag, 1)
                                .set(UserFile::getDeleteTime, DateUtil.getCurrentTime())
                                .set(UserFile::getDeleteBatchNum, deleteBatchNum)
                                .eq(UserFile::getUserFileId, userFileTemp.getUserFileId())
                                .eq(UserFile::getDeleteFlag, 0);
                        userfileMapper.update(null, userFileLambdaUpdateWrapper1);
                    }
                });

            }
        }).start();
    }
    ...
}
```

### Controller 层代码开发



打开 `com.shiyanlou.file.controller` 包，在该包下的 `FileController.java` 文件中，添加单个文件删除和批量文件删除操作接口，代码如下：

```java
...
import com.alibaba.fastjson.JSON;
import com.shiyanlou.file.dto.DeleteFileDTO;
import com.shiyanlou.file.dto.BatchDeleteFileDTO;

public class FileController {
    ...
    @Operation(summary = "删除文件", description = "可以删除文件或者目录", tags = { "file" })
    @RequestMapping(value = "/deletefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult deleteFile(@RequestBody DeleteFileDTO deleteFileDto, @RequestHeader("token") String token) {

        User sessionUser = userService.getUserByToken(token);

        userfileService.deleteUserFile(deleteFileDto.getUserFileId(), sessionUser.getUserId());

        return RestResult.success();

    }

    @Operation(summary = "批量删除文件", description = "批量删除文件", tags = { "file" })
    @RequestMapping(value = "/batchdeletefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<String> deleteImageByIds(@RequestBody BatchDeleteFileDTO batchDeleteFileDto,
            @RequestHeader("token") String token) {

        User sessionUser = userService.getUserByToken(token);

        List<UserFile> userFiles = JSON.parseArray(batchDeleteFileDto.getFiles(), UserFile.class);
        for (UserFile userFile : userFiles) {
            userfileService.deleteUserFile(userFile.getUserFileId(),sessionUser.getUserId());
        }

        return RestResult.success().message("批量删除文件成功");
    }
}
```

到此为止删除文件接口就开发完成了，我们会发现删除文件其实就是将删除标识从 0 修改为 1，接下来我们只需要在查询文件列表的时候把标记为 1 的文件过滤掉，只查询标记为 0 的文件，就实现了删除。

打开 `resource/mybatis/mapper` 路径，在 `UserfileMapper.xml` 文件中 **修改**查询文件列表接口，（注意下面代码实在之前的基础上修改），代码如下：

```xml
    <select id="userfileList" resultType="com.shiyanlou.file.vo.UserfileListVO">
        select * from userfile a
        left join file on file.fileId = a.fileId
        <where>
            <if test="userfile.userId != null">
                and a.userId = #{userfile.userId}
            </if>
            <if test="userfile.filePath != null">
                and a.filePath = #{userfile.filePath}
            </if>
            <if test="userfile.extendName != null">
                and a.extendName = #{userfile.extendName}
            </if>
            and a.deleteFlag = 0
        </where>
        ORDER BY  isDir desc
        limit #{beginCount}, #{pageCount}
    </select>

    <sql id="selectByExtendName" >
        left join file on file.fileId = userfile.fileId
        where extendName in
        <foreach collection="fileNameList" open="(" close=")" separator="," item="fileName" >
            #{fileName}
        </foreach>
        and userId = #{userId}
        and deleteFlag = 0
    </sql>
    <sql id="selectByNotExtendName">
        left join file on file.fileId = userfile.fileId
        where extendName not in
        <foreach collection="fileNameList" open="(" close=")" separator="," item="fileName" >
            #{fileName}
        </foreach>
        and userId = #{userId}
        and deleteFlag = 0
    </sql>
```

打开 `FileController.java` 类，修改获取文件查询列表接口，查询文件数量时增加删除标记条件，只查询未删除的文件，代码如下：

```java
...
public RestResult<UserfileListVO> getUserfileList(UserfileListDTO userfileListDto,
        @RequestHeader("token") String token) {
    ...
    //***修改点***，修改下面这一行代码，在末尾进行补充
    userFileLambdaQueryWrapper.eq(UserFile::getUserId, sessionUser.getUserId())
    .eq(UserFile::getFilePath, userfileListDto.getFilePath()).eq(UserFile::getDeleteFlag, 0);
    int total = userfileService.count(userFileLambdaQueryWrapper);

    Map<String, Object> map = new HashMap<>();
    map.put("total", total);
    map.put("list", fileList);

    return RestResult.success().data(map);

}
```

### 移动文件接口开发



在移动文件之前，需要对当前文件系统的目录结构进行显示，因此首先要做的就是展示当前目录树，代码如下：

### DTO 和 VO 实体类



在包 `com.shiyanlou.file.vo` 下创建 `TreeNodeVO.java` 类，用来展示目录结构，代码如下：

```java
package com.shiyanlou.file.vo;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;


@Schema(name = "树节点VO",required = true)
@Data
public class TreeNodeVO {

    @Schema(description = "节点id")
    private Long id;

    @Schema(description = "节点名")
    private String label;

    @Schema(description = "深度")
    private Long depth;

    @Schema(description = "是否被关闭")
    private String state = "closed";

    @Schema(description = "属性集合")
    private Map<String, String> attributes = new HashMap<>();

    @Schema(description = "子节点列表")
    private List<TreeNodeVO> children = new ArrayList<>();

}
```

在 `com.shiyanlou.file.dto` 包下创建 `MoveFileDTO.java` 类，并初始化内容如下：

```java
@Data
@Schema(name = "移动文件DTO",required = true)
public class MoveFileDTO {

    @Schema(description = "文件路径")
    private String filePath;

    @Schema(description = "文件名")
    private String fileName;

    @Schema(description = "旧文件名")
    private String oldFilePath;
    @Schema(description = "扩展名")
    private String extendName;

}
```

继续在该包下创建 `BatchMoveFileDTO.java` 类，并初始化内容如下：

```java
@Data
@Schema(name = "批量移动文件DTO",required = true)
public class BatchMoveFileDTO {
    @Schema(description="文件集合")
    private String files;
    @Schema(description="文件路径")
    private String filePath;
}
```

### DAO 层代码开发



打开 `com.shiyanlou.file.mapper` 包，在该包下 `UserfileMapper.java` 接口中，添加如下接口，代码如下：

```java
void updateFilepathByFilepath(String oldfilePath, String newfilePath, Long userId);
```

打开 `resource/mybatis/mapper` 目录，在该目录下 `UserfileMapper.xml` 文件中，添加 MyBatis 脚本，代码如下：

```xml
<update id="updateFilepathByFilepath">
    UPDATE userfile SET filePath=REPLACE(filePath, #{param1}, #{param2})
    WHERE filePath like N'${param1}%' and userId = #{param3}
</update>
```

### Service 层代码开发



打开 `com.shiyanlou.file.service` 包下的 `UserfileService.java` 类，并在该类中添加如下代码：

```java
List<UserFile> selectFilePathTreeByUserId(Long userId);
void updateFilepathByFilepath(String oldfilePath, String newfilePath, String fileName, String extendName, Long userId);
```

打开 `com.shiyanlou.file.service.impl` 包下的 `UserfileServiceImpl.java` 类，并在该类中添加如下代码：

```java
...
import org.apache.commons.lang3.StringUtils;

public class UserfileServiceImpl extends ServiceImpl<UserfileMapper, UserFile> implements UserfileService {
    ...
    @Override
    public void updateFilepathByFilepath(String oldfilePath, String newfilePath, String fileName, String extendName, Long userId) {
        if ("null".equals(extendName)){
            extendName = null;
        }

        LambdaUpdateWrapper<UserFile> lambdaUpdateWrapper = new LambdaUpdateWrapper<UserFile>();
        lambdaUpdateWrapper.set(UserFile::getFilePath, newfilePath)
        .eq(UserFile::getFilePath, oldfilePath)
        .eq(UserFile::getFileName, fileName)
        .eq(UserFile::getUserId, userId);
        if (StringUtils.isNotEmpty(extendName)) {
            lambdaUpdateWrapper.eq(UserFile::getExtendName, extendName);
        } else {
            lambdaUpdateWrapper.isNull(UserFile::getExtendName);
        }
        userfileMapper.update(null, lambdaUpdateWrapper);
        //移动子目录
        oldfilePath = oldfilePath + fileName + "/";
        newfilePath = newfilePath + fileName + "/";

        oldfilePath = oldfilePath.replace("\\", "\\\\\\\\");
        oldfilePath = oldfilePath.replace("'", "\\'");
        oldfilePath = oldfilePath.replace("%", "\\%");
        oldfilePath = oldfilePath.replace("_", "\\_");

        if (extendName == null) { //为null说明是目录，则需要移动子目录
            userfileMapper.updateFilepathByFilepath(oldfilePath, newfilePath, userId);
        }
    }

    ...

    @Override
    public List<UserFile> selectFilePathTreeByUserId(Long userId) { LambdaQueryWrapper<UserFile> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(UserFile::getUserId, userId)
                .eq(UserFile::getIsDir, 1);
        return userfileMapper.selectList(lambdaQueryWrapper);
    }

    ...
}
```

### Controller 层代码开发



打开 `com.shiyanlou.file.controller` 包，在该包下的 `FileController.java` 文件中，添加获取文件树接口，代码如下：

```java
import com.shiyanlou.file.vo.TreeNodeVO;
import java.util.Queue;
import java.util.LinkedList;

public class FileController {

    ...
    @Operation(summary = "获取文件树", description = "文件移动的时候需要用到该接口，用来展示目录树", tags = {"file"})
    @RequestMapping(value = "/getfiletree", method = RequestMethod.GET)
    @ResponseBody
    public RestResult<TreeNodeVO> getFileTree(@RequestHeader("token") String token){
        RestResult<TreeNodeVO> result = new RestResult<TreeNodeVO>();
        UserFile userFile = new UserFile();
        User sessionUser = userService.getUserByToken(token);
        userFile.setUserId(sessionUser.getUserId());

        List<UserFile> filePathList = userfileService.selectFilePathTreeByUserId(sessionUser.getUserId());
        TreeNodeVO resultTreeNode = new TreeNodeVO();
        resultTreeNode.setLabel("/");

        for (int i = 0; i < filePathList.size(); i++){
            String filePath = filePathList.get(i).getFilePath() + filePathList.get(i).getFileName() + "/";

            Queue<String> queue = new LinkedList<>();

            String[] strArr = filePath.split("/");
            for (int j = 0; j < strArr.length; j++){
                if (!"".equals(strArr[j]) && strArr[j] != null){
                    queue.add(strArr[j]);
                }

            }
            if (queue.size() == 0){
                continue;
            }
            resultTreeNode = insertTreeNode(resultTreeNode,"/", queue);


        }
        result.setSuccess(true);
        result.setData(resultTreeNode);
        return result;

    }
    ...
}
```

上面这段代码需要另外调用一段递归代码，这段代码逻辑主要是将查询出来的文件路径组装成树形结构，代码如下：

```java
public TreeNodeVO insertTreeNode(TreeNodeVO treeNode, String filePath, Queue<String> nodeNameQueue){

    List<TreeNodeVO> childrenTreeNodes = treeNode.getChildren();
    String currentNodeName = nodeNameQueue.peek();
    if (currentNodeName == null){
        return treeNode;
    }

    Map<String, String> map = new HashMap<>();
    filePath = filePath + currentNodeName + "/";
    map.put("filePath", filePath);

    if (!isExistPath(childrenTreeNodes, currentNodeName)){  //1、判断有没有该子节点，如果没有则插入
        //插入
        TreeNodeVO resultTreeNode = new TreeNodeVO();


        resultTreeNode.setAttributes(map);
        resultTreeNode.setLabel(nodeNameQueue.poll());
        // resultTreeNode.setId(treeid++);

        childrenTreeNodes.add(resultTreeNode);

    }else{  //2、如果有，则跳过
        nodeNameQueue.poll();
    }

    if (nodeNameQueue.size() != 0) {
        for (int i = 0; i < childrenTreeNodes.size(); i++) {

            TreeNodeVO childrenTreeNode = childrenTreeNodes.get(i);
            if (currentNodeName.equals(childrenTreeNode.getLabel())){
                childrenTreeNode = insertTreeNode(childrenTreeNode, filePath, nodeNameQueue);
                childrenTreeNodes.remove(i);
                childrenTreeNodes.add(childrenTreeNode);
                treeNode.setChildren(childrenTreeNodes);
            }

        }
    }else{
        treeNode.setChildren(childrenTreeNodes);
    }

    return treeNode;

}

public boolean isExistPath(List<TreeNodeVO> childrenTreeNodes, String path){
    boolean isExistPath = false;

    try {
        for (int i = 0; i < childrenTreeNodes.size(); i++){
            if (path.equals(childrenTreeNodes.get(i).getLabel())){
                isExistPath = true;
            }
        }
    }catch (Exception e){
        e.printStackTrace();
    }


    return isExistPath;
}
```

上面已经可以将目录树展示出来了，接下来完成最后真正的移动文件接口，移动文件接口的本质其实就是将保存到数据库中的虚拟路径做一个修改即可，真实的保存在磁盘上的文件是不需要做任何变动的，代码如下：

```java
...
import com.shiyanlou.file.dto.MoveFileDTO;
import com.shiyanlou.file.dto.BatchMoveFileDTO;

public class FileController {
    ...
    @Operation(summary = "文件移动", description = "可以移动文件或者目录", tags = { "file" })
    @RequestMapping(value = "/movefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<String> moveFile(@RequestBody MoveFileDTO moveFileDto, @RequestHeader("token") String token) {
        User sessionUser = userService.getUserByToken(token);
        String oldfilePath = moveFileDto.getOldFilePath();
        String newfilePath = moveFileDto.getFilePath();
        String fileName = moveFileDto.getFileName();
        String extendName = moveFileDto.getExtendName();

        userfileService.updateFilepathByFilepath(oldfilePath, newfilePath, fileName, extendName, sessionUser.getUserId());
        return RestResult.success();

    }

    @Operation(summary = "批量移动文件", description = "可以同时选择移动多个文件或者目录", tags = { "file" })
    @RequestMapping(value = "/batchmovefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<String> batchMoveFile(@RequestBody BatchMoveFileDTO batchMoveFileDto,
            @RequestHeader("token") String token) {

        User sessionUser = userService.getUserByToken(token);
        String files = batchMoveFileDto.getFiles();
        String newfilePath = batchMoveFileDto.getFilePath();
        List<UserFile> userFiles = JSON.parseArray(files, UserFile.class);

        for (UserFile userFile : userFiles) {
            userfileService.updateFilepathByFilepath(userFile.getFilePath(), newfilePath, userFile.getFileName(),
                    userFile.getExtendName(), sessionUser.getUserId());
        }

        return RestResult.success().data("批量移动文件成功");

    }
    ...
}
```

### TO 和 VO 实体类开发



在包 `com.shiyanlou.file.dto` 下创建 `RenameFileDTO.java` 类，用来接受重命名接口传参，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "重命名文件DTO",required = true)
public class RenameFileDTO {
    private Long userFileId;

    @Schema(description = "文件名")
    private String fileName;

}
```

### DAO 层代码开发



打开 `com.shiyanlou.file.mapper` 包，在该包下 `UserfileMapper.java` 接口中，添加如下接口，代码如下：

```java
import org.apache.ibatis.annotations.Param;
public interface UserfileMapper extends BaseMapper<UserFile> {
    ...
    void replaceFilePath(@Param("filePath") String filePath, @Param("oldFilePath") String oldFilePath, @Param("userId") Long userId);
    Long selectStorageSizeByUserId(Long userId);
}
```

打开 `resource/mybatis/mapper` 目录，在该目录下 `UserfileMapper.xml` 文件中，添加 MyBatis 脚本，代码如下：

```xml
<update id="replaceFilePath">
    UPDATE userfile SET filepath=REPLACE(filepath, #{oldFilePath}, #{filePath})
    WHERE filepath LIKE N'${oldFilePath}%' and userId = #{userId};
</update>
```

### Service 层代码开发



打开 `com.shiyanlou.file.service` 包下的 `UserfileService.java` 类，并在该类中添加如下代码：

```java
List<UserFile> selectUserFileByNameAndPath(String fileName, String filePath, Long userId);
void replaceUserFilePath(String filePath, String oldFilePath, Long userId);
```

打开 `com.shiyanlou.file.service.impl` 包下的 `UserfileServiceImpl` 类，并在该类中添加如下代码实现：

```java
    @Override
    public List<UserFile> selectUserFileByNameAndPath(String fileName, String filePath, Long userId) {
        LambdaQueryWrapper<UserFile> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(UserFile::getFileName, fileName)
                .eq(UserFile::getFilePath, filePath)
                .eq(UserFile::getUserId, userId)
                .eq(UserFile::getDeleteFlag, "0");
        return userfileMapper.selectList(lambdaQueryWrapper);
    }

    @Override
    public void replaceUserFilePath(String filePath, String oldFilePath, Long userId) {
        userfileMapper.replaceFilePath(filePath, oldFilePath, userId);
    }
```

### Controller 层代码开发



打开 `com.shiyanlou.file.controller` 包，在该包下的 `FileController.java` 文件中，添加文件重命名接口，代码如下：

```java
import com.shiyanlou.file.dto.RenameFileDTO;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.shiyanlou.file.model.File;

public class FileController {
    ...
    @Operation(summary = "文件重命名", description = "文件重命名", tags = {"file"})
    @RequestMapping(value = "/renamefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<String> renameFile(@RequestBody RenameFileDTO renameFileDto, @RequestHeader("token") String token) {
        User sessionUser = userService.getUserByToken(token);
        UserFile userFile = userfileService.getById(renameFileDto.getUserFileId());

        List<UserFile> userFiles = userfileService.selectUserFileByNameAndPath(renameFileDto.getFileName(), userFile.getFilePath(), sessionUser.getUserId());
        if (userFiles != null && !userFiles.isEmpty()) {
            return RestResult.fail().message("同名文件已存在");

        }
        if (1 == userFile.getIsDir()) {
            LambdaUpdateWrapper<UserFile> lambdaUpdateWrapper = new LambdaUpdateWrapper<>();
            lambdaUpdateWrapper.set(UserFile::getFileName, renameFileDto.getFileName())
                    .set(UserFile::getUploadTime, DateUtil.getCurrentTime())
                    .eq(UserFile::getUserFileId, renameFileDto.getUserFileId());
            userfileService.update(lambdaUpdateWrapper);
            userfileService.replaceUserFilePath(userFile.getFilePath() + renameFileDto.getFileName() + "/",
                    userFile.getFilePath() + userFile.getFileName() + "/", sessionUser.getUserId());
        } else {
            File file = fileService.getById(userFile.getFileId());

            LambdaUpdateWrapper<UserFile> lambdaUpdateWrapper = new LambdaUpdateWrapper<>();
            lambdaUpdateWrapper.set(UserFile::getFileName, renameFileDto.getFileName())
                    .set(UserFile::getUploadTime, DateUtil.getCurrentTime())
                    .eq(UserFile::getUserFileId, renameFileDto.getUserFileId());
            userfileService.update(lambdaUpdateWrapper);


        }

        return RestResult.success();
    }
    ...
}
```

### Dao 层代码开发



打开 `com.shiyanlou.file.mapper` 包，在该包下 `UserfileMapper.java` 接口中，添加如下接口，代码如下：

```java
Long selectStorageSizeByUserId(@Param("userId") Long userId);
```

打开 `resource/mybatis/mapper` 目录，在该目录下 `UserfileMapper.xml` 文件中，添加 MyBatis 脚本，代码如下：

```xml
<select id="selectStorageSizeByUserId" resultType="java.lang.Long" parameterType="java.lang.Long">
    SELECT SUM(fileSize) FROM userfile
    LEFT JOIN file ON file.fileId = userfile.fileId
    WHERE userfile.userId = #{userId} and deleteFlag = 0
</select>
```

### Service 层代码开发



打开 `com.shiyanlou.file.service` 包下的 `FiletransferService.java` 类，并在该类中添加如下代码：

```java
Long selectStorageSizeByUserId(Long userId);
```

打开 `com.shiyanlou.file.service.impl` 包下的 `FiletransferServiceImpl.java` 类，并在该类中添加如下代码：

```java
@Override
public Long selectStorageSizeByUserId(Long userId) {
    return userfileMapper.selectStorageSizeByUserId(userId);
}
```

### Controller 层代码开发



打开 `com.shiyanlou.file.controller` 包，并在 `FiletransferController.java` 接口中添加如下代码：

```java
...
import com.shiyanlou.file.model.Storage;

public class FiletransferController {
    ...
    @Operation(summary = "获取存储信息", description = "获取存储信息", tags = {"filetransfer"})
    @RequestMapping(value = "/getstorage", method = RequestMethod.GET)
    @ResponseBody
    public RestResult<Long> getStorage(@RequestHeader("token") String token) {

        User sessionUserBean = userService.getUserByToken(token);
        Storage storageBean = new Storage();


        Long storageSize = filetransferService.selectStorageSizeByUserId(sessionUserBean.getUserId());
        return RestResult.success().data(storageSize);

    }
}
```

打开 `com.shiyanlou.file.model` 包，新建 `Storage.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import lombok.Data;

@Data
@Table(name = "storage")
@Entity
@TableName("storage")
public class Storage {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @TableId(type = IdType.AUTO)
    @Column(columnDefinition="bigint(20)")
    private Long storageId;

    @Column(columnDefinition="bigint(20)")
    private Long userId;

    @Column(columnDefinition="bigint(20)")
    private Long storageSize;

}
```
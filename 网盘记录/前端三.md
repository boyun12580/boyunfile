### 文件单个操作



对单个文件的操作，包括删除、移动、下载和重命名，操作入口在文件表格操作列的各个按钮。先来把接下来要用到的接口维护在 `src/request/file.js` 中：

```javascript
...
// 获取文件夹列表 树状结构
export const getFileTree = (p) => get('/file/getfiletree', p)

// 单文件操作接口
// 文件删除
export const deleteFile = (p) => post('/file/deletefile', p)
// 文件移动
export const moveFile = (p) => post('/file/movefile', p)
// 文件重命名
export const renameFile = (p) => post('/file/renamefile', p)
```

### 文件删除



在 `FileTable.vue` 中，已经将文件删除函数添加了，现在来在函数内部调用删除接口，在这之前，需要先提示用户是否确定删除，因此需要用到 Element UI 的 [MessageBox](https://element.eleme.cn/#/zh-CN/component/message-box#que-ren-xiao-xi) 组件。删除文件之后需要刷新文件列表：

```
<script>
import { deleteFile } from '@/request/file.js' //  引入接口

export default {
  name: 'FileTable',
  ...
  methods: {
    // 删除按钮 - 点击事件
    handleClickDelete(row) {
      // 消息弹框提示用户
      this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      })
        .then(() => {
          // 确定按钮 点击事件 调用删除文件接口
          deleteFile(row).then((res) => {
            if (res.success) {
              this.$emit('getTableData') //  刷新文件列表
              this.$message.success('删除成功')
            } else {
              this.$message.error(res.message)
            }
          })
        })
        .catch(() => {
          //  取消
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
    },
    ...
  }
}
</script>
```

在 `src/views/Home/index.vue` 中接收子组件的刷新文件列表事件 `@getTableData="getFileData"`：

```
<!-- 表格组件 - 文件展示区 -->
<FileTable
  :tableData="tableData"
  :loading="loading"
  @getTableData="getFileData"
></FileTable>
```

### 文件移动



考虑到接下来的文件批量操作，把文件移动封装为公共组件。在 `src/views/Home/components` 下新建文件 `MoveFileDialog.vue`，内容稍后来讲。

在 `FileTable.vue` 中，已经将文件移动函数添加了，函数内部向父组件 `index.vue` 触发事件，以打开移动文件对话框，并保存当前行文件数据：

```javascript
// 移动按钮 - 点击事件
handleClickMove(row) {
    this.$emit('handleSelectFile', false, row) // true/false 操作类型：批量移动/单文件操作；row 当前行文件数据
    this.$emit('handleMoveFile', true) // true/false 打开/关闭移动文件对话框
},
```

父组件 `index.vue` 中接收事件，添加 `@handleSelectFile="setOperationFile"` 和 `@handleMoveFile="setMoveFileDialog"`：

```
<!-- 表格组件 - 文件展示区 -->
<FileTable
  :tableData="tableData"
  :loading="loading"
  @getTableData="getFileData"
  @handleSelectFile="setOperationFile"
  @handleMoveFile="setMoveFileDialog"
></FileTable>
```

回调函数内部执行操作：打开选择目标路径对话框，并保存当前行文件数据和操作类型，继续编辑 `index.vue` 文件：

```
<script>
...
import { getFileTree } from '@/request/file.js' //  引入获取文件夹列表 树状结构 接口

export default {
  name: 'Home',
  ...
  data() {
    return {
      ...
      //  移动文件模态框数据
      dialogMoveFile: {
        visible: false, //  对话框是否显示
        fileTree: [] //  目录树
      },
      isBatch: false, //  是否批量移动
      operationFile: {}, // 单个操作的文件信息
      operationFileList: [] // 批量操作的文件信息
    }
  },
  ...
  methods: {
    ...
    /**
     * 设置移动文件时的文件信息
     * @param {Boolean} isBatch 是否批量移动，true 是批量移动，false 是单个文件操作
     * @param {Object | Array} file 需要移动的文件信息，单个操作时为Oject，批量操作时，为Array
     */
    setOperationFile(isBatch, file) {
      this.isBatch = isBatch //  保存操作类型
      if (isBatch) {
        this.operationFileList = file //  批量操作文件
      } else {
        this.operationFile = file //  单个操作文件
      }
    },
    /**
     * 设置移动文件对话框相关数据
     * @param {Boolean} visible 打开/关闭移动文件模态框
     */
    setMoveFileDialog(visible) {
      this.dialogMoveFile.visible = visible //  打开对话框
      if (visible) {
        // 打开对话框时，获取文件夹目录树
        getFileTree().then((res) => {
          if (res.success) {
            this.dialogMoveFile.fileTree = [res.data]
          } else {
            this.$message.error(res.message)
          }
        })
      }
    }
  }
}
</script>
...
```

接下来添加 `MoveFileDialog.vue` 的内容：使用 Element UI 的 [Tree 树形控件](https://element.eleme.cn/#/zh-CN/component/tree#tree-shu-xing-kong-jian) ，在对话框内以树形结构显示文件夹，并使用树形控件的 `node-click` 事件，获取当前点击的文件夹路径，向父组件触发事件，在父组件中保存移动文件的目标路径。对话框点击确定按钮时，向父组件触发事件，在回调函数中调用移动文件接口；对话框点击取消按钮时，关闭对话框：

```
<template>
  <div class="move-dialog-wrapper">
    <!-- 移动文件-选择目录模态框 -->
    <el-dialog title="选择目录" :visible.sync="dialogMoveFile.visible">
      <div class="el-dialog-div">
        <el-tree
          :data="dialogMoveFile.fileTree"
          :props="defaultProps"
          :highlight-current="true"
          default-expand-all
          @node-click="selectNodeClick"
        ></el-tree>
      </div>
      <div slot="footer" class="dialog-footer">
        <el-button @click="$emit('handleMoveFile', false)">取 消</el-button>
        <el-button type="primary" @click="$emit('confirmMoveFile')"
          >确 定</el-button
        >
      </div>
    </el-dialog>
  </div>
</template>

<script>
export default {
  name: "MoveFileDialog",
  props: {
    dialogMoveFile: Object,
  },
  data() {
    return {
      defaultProps: {
        children: "children",
        label: "label",
      },
    };
  },
  methods: {
    //  移动文件模态框：选择目录事件
    selectNodeClick(data) {
      let selectFilePath = data.attributes.filePath
        ? data.attributes.filePath
        : "/";
      this.$emit("setSelectFilePath", selectFilePath);
    },
  },
};
</script>

<style lang="stylus" scoped>
.move-dialog-wrapper {
  >>> .el-dialog {
    .el-dialog__header {
      display: flex;
    }

    .el-dialog__body {
      padding: 10px 30px;

      .el-dialog-div {
        height: 300px;
        overflow: auto;
        setScrollbar(6px);

        .el-tree {
          .el-tree-node__content {
            height: 34px;
            font-size: 16px;

            .el-icon-caret-right {
              font-size: 18px;
            }
          }

          .el-tree-node.is-current>.el-tree-node__content {
            color: #409EFF;

            .el-tree-node__expand-icon {
              color: inherit;
            }
          }
        }
      }
    }
  }
}
</style>
```

在父组件 `index.vue` 中引入 `MoveFileDialog.vue`，并按照上述说明，在回调函数中添加相应操作：

```
<template>
  <div class="home">
    ...
    <!-- 3. 使用移动文件模态框 -->
    <MoveFileDialog
      :dialogMoveFile="dialogMoveFile"
      @setSelectFilePath="setSelectFilePath"
      @confirmMoveFile="confirmMoveFile"
      @handleMoveFile="setMoveFileDialog"
    ></MoveFileDialog>
  </div>
</template>

<script>
...
import MoveFileDialog from './components/MoveFileDialog' //  1. 引入移动文件组件
import { moveFile } from '@/request/file.js' //  引入获取文件列表接口

export default {
  name: 'Home',
  components: {
    ...
    MoveFileDialog //  2. 注册移动文件组件
  },
  data() {
    return {
      ...
      selectFilePath: '' //  目标路径
    }
  },
  methods: {
    ...
    //  设置移动文件的目标路径
    setSelectFilePath(selectFilePath) {
      this.selectFilePath = selectFilePath
    },
    //  移动文件模态框-确定按钮事件
    confirmMoveFile() {
      if (this.isBatch) {
        //  批量移动
      } else {
        //  单文件移动
        let data = {
          filePath: this.selectFilePath, //  目标路径
          oldFilePath: this.operationFile.filePath, //  原路径
          fileName: this.operationFile.fileName, //  文件名称
          extendName: this.operationFile.extendName //  文件扩展名
        }
        moveFile(data).then((res) => {
          if (res.success) {
            this.$message.success('移动文件成功')
            this.getFileData() //  刷新文件列表
            this.dialogMoveFile.visible = false //  关闭对话框
          } else {
            this.$message.error(res.message)
          }
        })
      }
    }
  }
}
</script>
...
```

### 文件下载



下载按钮添加显隐控制 `v-if="scope.row.isDir === 0"`，当前行的文件类型不是文件夹时才可下载，同时在 `<a>` 标签的 href 属性中添加下载链接，修改 `FileTable.vue` 文件：

```
<!-- 操作列展开状态下的下载按钮 -->
<el-button type="text" size="small" v-if="scope.row.isDir === 0">
    <a
       :href="`/api/filetransfer/downloadfile?userFileId=${scope.row.userFileId}`"
       target="_blank"
       style="display: block; color: inherit"
       >下载</a
     >
</el-button>
...

<!-- 操作列收缩状态下的下载按钮 -->
<el-dropdown-item v-if="scope.row.isDir === 0">
    <a
       :href="`/api/filetransfer/downloadfile?userFileId=${scope.row.userFileId}`"
       target="_blank"
       style="display: block; color: inherit"
       >下载</a
    >
</el-dropdown-item>
```

来处理下 `<a>` 标签的下划线，在 `src/assets/style/base.styl` 中添加样式：

```stylus
a {
  text-decoration: none;
}
```

### 文件重命名



在 `FileTable.vue` 中，文件重命名的函数已添加，函数内部执行以下操作：先打开消息弹框让用户输入新文件名，点击确定按钮后，调用重命名接口。

```
<script>
import { renameFile } from '@/request/file.js' //  引入文件重命名接口

export default {
  name: 'FileTable',
  ...
  methods: {
    ...
    // 重命名按钮 - 点击事件
    handleClickRename(row) {
      var fileName = row.fileName
      this.$prompt('请输入文件名', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        inputValue: fileName,
        inputPattern: /\S/, //  文件名不能为空
        inputErrorMessage: '请输入文件名',
        closeOnClickModal: false
      })
        .then(({ value }) => {
          // 确定按钮 调用重命名接口
          renameFile({
            ...row,
            fileName: value
          }).then((res) => {
            if (res.success) {
              this.$emit('getTableData') //  刷新文件列表
              this.$message.success('文件已重命名')
            } else {
              this.$message.error(res.message)
            }
          })
        })
        .catch(() => {
          this.$message({
            type: 'info',
            message: '取消'
          })
        })
    }
  }
}
</script>
```

### 文件批量操作



对文件的批量操作，包括删除、移动、下载，文件的选择需要在表格列的每行添加勾选框，操作按钮将会放置在顶部的操作按钮组中。操作流程如下：

1. 勾选需要批量操作的表格行，保存用户已勾选的表格行；
2. 点击批量操作按钮（删除/移动/下载）；
3. 执行批量操作；
4. 批量操作结束，刷新文件列表。

先来把接下来要用到的接口维护在 `src/request/file.js` 中：

```javascript
// 批量文件操作接口
// 批量删除文件
export const batchDeleteFile = (p) => post("/file/batchdeletefile", p);
// 批量移动文件
export const batchMoveFile = (p) => post("/file/batchmovefile", p);
```

### 文件列表勾选框添加



在 `FileTable.vue` 中，参考 Element UI 的[多选表格官方示例](https://element.eleme.cn/#/zh-CN/component/table#duo-xuan)在表格第一列前添加 `type="selection"` 的列，并在表格上添加 `@selection-change="handleSelectRow"`，当选择项发生变化时会触发该事件，并将已选项通过事件抛出，在父组件中保存：

```
<template>
  <el-table
    class="file-table"
    :data="tableData"
    height="calc(100vh - 202px)"
    style="width: 100%"
    v-loading="loading"
    @selection-change="handleSelectRow"
  >
    <!-- 勾选框 -->
    <el-table-column
      type="selection"
      width="56"
      align="center"
    ></el-table-column>
    <!-- 已有代码不再赘述 -->
    ...
  </el-table>
</template>

<script>
export default {
  name: 'FileTable',
  methods: {
    ...
    // 表格行勾选事件
    handleSelectRow(selection) {
      this.$emit('handleSelectFile', true, selection) // true/false 批量移动/单文件操作；selection 勾选的表格行数据
    },
    ...
  }
}
</script>
```

在父组件 `index.vue` 中将保存的已选项数据 `operationFileList`，传递给操作按钮组：

```
<OperationMenu
  :fileType="fileType"
  :filePath="filePath"
  :operationFileList="operationFileList"
  @getTableData="getFileData"
  @handleUploadFile="handleUploadFile"
></OperationMenu>
```

在操作按钮组组件 `OperationMenu.vue` 中，接收该值，这样批量删除、批量下载的事件均在此组件中执行即可：

```javascript
props: {
    ...
    // 表格行 已选项
    operationFileList: {
        type: Array,
        required: true
    }
  },
```

### 文件批量删除



在操作按钮组组件 `OperationMenu.vue` 中添加删除按钮，并添加按钮点击事件：

```
<!-- 按钮组 -->
<el-button-group class="operate-group">
    <!-- 已有代码不再赘述 -->
    ...
    <!-- disabled 当表格勾选项为空时，禁用删除按钮 -->
    <el-button
        size="mini"
        type="primary"
        icon="el-icon-delete"
        :disabled="!operationFileList.length"
        @click="handleDeleteFileClick()"
        >删除</el-button
    >
  </el-button-group>
```

在按钮点击事件中，和删除单文件步骤类似，询问用户是否确定删除，确定时调用批量删除文件接口，删除成功后刷新文件列表，继续编辑 `OperationMenu.vue` 文件：

```
<script>
...
import { batchDeleteFile } from '@/request/file.js' //  引入批量删除文件接口

export default {
  name: 'OperationMenu',
  methods: {
    ...
    // 删除文件按钮 - 点击事件
    handleDeleteFileClick() {
      // 消息弹框提示用户
      this.$confirm('此操作将永久删除文件, 是否继续?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      })
        .then(() => {
          // 确定按钮 点击事件 调用批量删除文件接口
          batchDeleteFile({
            files: JSON.stringify(this.operationFileList)
          }).then((res) => {
            if (res.success) {
              this.$message({
                message: res.message,
                type: 'success'
              })
              this.$emit('getTableData') //  刷新文件列表
            } else {
              this.$message.error('失败' + res.message)
            }
          })
        })
        .catch(() => {
          //  取消
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
    }
  }
}
</script>
```

### 文件批量移动



在实现单文件移动时，已经将文件夹列表的展示封装为了公共组件，这里还是使用该组件选择目标路径，在`OperationMenu.vue` 中向父组件中抛出事件，打开路径选择对话框。

先在 `OperationMenu.vue` 中添加移动按钮，这里需要做个显隐控制：只有左侧菜单选择全部时，才显示移动按钮；并给移动按钮添加点击事件：

```
<!-- 按钮组 -->
<el-button-group class="operate-group">
    <!-- 已有代码不再赘述 -->
    ...
    <!-- disabled 当表格勾选项为空时，禁用移动按钮 | v-if 当左侧菜单选择全部时，才显示移动按钮 -->
    <el-button
        size="mini"
        type="primary"
        icon="el-icon-rank"
        :disabled="!operationFileList.length"
        v-if="fileType === 0"
        @click="handleMoveFileClick()"
        >移动</el-button
    >
</el-button-group>
// 移动文件按钮 - 点击事件
handleMoveFileClick() {
    // true/false 批量移动/单文件操作 | this.operationFileList 当前行文件数据
    this.$emit('handleSelectFile', true, this.operationFileList)
    this.$emit('handleMoveFile', true) // true/false 打开/关闭移动文件对话框
}
```

在父组件 `index.vue` 中接收事件 `@handleSelectFile` 和 `@handleMoveFile`：

```
<OperationMenu
  :fileType="fileType"
  :filePath="filePath"
  :operationFileList="operationFileList"
  @getTableData="getFileData"
  @handleUploadFile="handleUploadFile"
  @handleSelectFile="setOperationFile"
  @handleMoveFile="setMoveFileDialog"
></OperationMenu>
```

在回调函数 `setMoveFileDialog()` 内打开目标路径选择对话框，对话框点击确定按钮时，需要在回调函数 `confirmMoveFile()` 中调用批量移动文件接口：

```javascript
import { batchMoveFile } from '@/request/file.js'

//  移动文件模态框-确定按钮事件
confirmMoveFile() {
    if (this.isBatch) {
        //  批量移动
        let data = {
          filePath: this.selectFilePath,
          files: JSON.stringify(this.operationFileList)
        }
        batchMoveFile(data).then((res) => {
          if (res.success) {
            this.$message.success(res.data)
            this.getFileData() //  刷新文件列表
            this.dialogMoveFile.visible = false //  关闭对话框
            this.operationFileList = []
          } else {
            this.$message.error(res.message)
          }
        })
    } else {
        //  单文件移动
        //  ......已有代码不再赘述
        ...
    }
}
```

### 文件批量下载



文件下载仍然采用 `<a>` 标签来实现，点击下载按钮时，触发 `<a>` 的点击事件，开始下载文件。在 `OperationMenu.vue` 中添加以下内容，同样需要做按钮禁用处理：

```
<template>
  <div class="operation-menu-wrapper">
    <!-- 按钮组 -->
    <el-button-group class="operate-group">
      <!-- 已有代码不再赘述 -->
      ...
      <!-- disabled 当表格勾选项为空时，禁用下载按钮 -->
      <el-button
        size="mini"
        type="primary"
        icon="el-icon-download"
        :disabled="!operationFileList.length"
        @click="handleDownloadFileClick()"
        >下载</el-button
      >
    </el-button-group>
    ...
    <!-- 多选文件下载，页面隐藏 -->
    <a
      v-for="(item, index) in operationFileList"
      :key="index"
      :href="`/api/filetransfer/downloadfile?userFileId=${item.userFileId}`"
      :download="`${item.fileName}.${item.extendName}`"
      :ref="`downloadLink${index}`"
    ></a>
  </div>
</template>

<script>
export default {
  name: 'OperationMenu',
  ...
  methods: {
    ...
    // 下载文件按钮 - 点击事件
    handleDownloadFileClick() {
      for (let i = 0; i < this.operationFileList.length; i++) {
        this.$refs[`downloadLink${i}`][0].click() //  依次调用 a 标签的点击事件来下载文件
      }
    }
  }
}
</script>
```

### 完善文件表格数据回显



当左侧菜单点击**图片/文档/视频/音乐/其他**时，在右侧表格中添加一列——文件所在路径；点击路径，可以直接跳转到该路径下，右侧表格显示该路径下的文件列表。

把 fileType 传递给文件表格组件，在 `index.vue` 中添加 `:fileType="fileType"`：

```
<!-- 表格组件 - 文件展示区 -->
<FileTable
  :tableData="tableData"
  :loading="loading"
  :fileType="fileType"
  @getTableData="getFileData"
  @handleSelectFile="setOperationFile"
  @handleMoveFile="setMoveFileDialog"
></FileTable>
```

在 `FileTable.vue` 中接收 fileType：

```javascript
props: {
    // 文件类型
    fileType: {
        type: Number,
        required: true
    }
}
```

在 `FileTable.vue` 中实现跳转功能：

```
<el-table
  class="file-table"
  :data="tableData"
  height="calc(100vh - 202px)"
  style="width: 100%"
  v-loading="loading"
  @selection-change="handleSelectRow"
>
    <!-- 已有代码不再赘述 -->
    ...
    <el-table-column
      label="所在路径"
      prop="filePath"
      show-overflow-tooltip
      v-if="fileType !== 0"
    >
      <template slot-scope="scope">
        <div
          style="cursor: pointer"
          title="点击跳转"
          @click="
            $router.push({
              query: { fileType: 0, filePath: scope.row.filePath }
            })
          "
        >
          {{ scope.row.filePath }}
        </div>
      </template>
    </el-table-column>
    ...
</el-table>
```

### 图片三种展示方式



点击左侧菜单的**图片**，右侧现在是以列表模式来展示图片的，接下来添加两种查看模式：网格模式和时间线模式。当切换网格模式时，图片将平铺显示，切换时间线模式时，图片将按照时间分组展示，类似于时间轴。同时，要实现刷新页面时保存刚才选择的图片展示方式。

### 结合 Vuex 实现图片展示方式保存



之前的实验已经结合 Vuex 实现过保存表格列显隐状态，这次同理。在 `src/views/Home/components` 下新建文件 `ShowModel.vue`，内容稍后来讲。

在 `src/views/Home/index.vue` 中引入该组件，将 fileType 传递给该组件，并对样式做些调整：

```
<script>
...
import ShowModel from './components/ShowModel.vue' //  1. 引入查看模式切换组件

export default {
  name: 'Home',
  components: {
    ...
    ShowModel //  2. 注册查看模式切换组件
  },
  ...
  computed: {
    ...
    // 查看模式
    showModel() {
      return this.$store.getters.showModel
    }
  },
}
</script>
<div class="operation-wrapper">
    <OperationMenu
        :fileType="fileType"
        :filePath="filePath"
        :operationFileList="operationFileList"
        @getTableData="getFileData"
        @handleUploadFile="handleUploadFile"
        @handleSelectFile="setOperationFile"
        @handleMoveFile="setMoveFileDialog"
        ></OperationMenu>
       <!-- 3. 使用查看模式切换组件 将 fileType 传递给子组件 -->
    <ShowModel :fileType="fileType"></ShowModel>
    <SelectColumn></SelectColumn>
</div>
.operation-wrapper {
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;

    // 左侧菜单按钮组 样式调整
    >>> .operation-menu-wrapper {
        flex: 1;
    }
}
```

在 `ShowModel` 使用 Element UI 的[单选按钮组](https://element.eleme.cn/#/zh-CN/component/radio#an-niu-yang-shi)来实现图片展示方式的切换，编辑 `ShowModel.vue` 文件：

```
<template>
  <div class="change-file-model">
    <!-- v-if 只有左侧菜单选择图片时 才展示此组件 -->
    <el-radio-group
      v-if="fileType === 1"
      v-model="currentshowModel"
      size="mini"
    >
      <el-radio-button :label="0">
        <i class="el-icon-tickets"></i> 列表
      </el-radio-button>
      <el-radio-button :label="1">
        <i class="el-icon-s-grid"></i> 网格
      </el-radio-button>
      <el-radio-button :label="2">
        <i class="el-icon-date"></i> 时间线
      </el-radio-button>
    </el-radio-group>
  </div>
</template>

<script>
export default {
  name: "ShowModel",
  props: {
    // 文件类型
    fileType: {
      type: Number,
      required: true,
    },
  },
  data() {
    return {};
  },
  computed: {
    //  查看模式 - 0 列表 | 1 网格 | 2 时间线
    currentshowModel: {
      get() {
        return this.$store.getters.showModel;
      },
      set(val) {
        this.$store.commit("changeShowModel", val); //  修改查看模式
      },
    },
  },
};
</script>

<style lang="stylus" scoped>
.change-file-model {
  margin-right: 16px;
}
</style>
```

结合 Vuex 保存图片展示方式，在 `src/store/module/file.js` 中添加 `showModel`：

```javascript
export default {
  state: {
    ...
    showModel: sessionStorage.getItem('showModel') //  查看模式 - 0 列表 | 1 网格 | 2 时间线
  },
  mutations: {
    ...
    // 切换查看模式
    changeShowModel(state, data) {
      sessionStorage.setItem('showModel', data)
      state.showModel = data
    }
  }
}
```

在 `src/store/index.js` 中的 getters 中添加：

```javascript
getters: {
  ...
  // 查看模式 - 0 列表 | 1 网格 | 2 时间线
  showModel: (state) => (state.file.showModel === null ? 0 : Number(state.file.showModel))
}
```

### 网格模式



在 `src/views/Home/components` 下新建文件 `FileGrid.vue`，内容稍后添加。

在 `index.vue` 中引入此组件，并对现有的文件表格组件和此组件做显隐控制：

```
<template>
  <div class="home">
    <!-- 右侧内容区 -->
    <div class="home-right">
      <!-- 已有代码不再赘述 -->
      ...
      <!-- 表格组件 v-if 当左侧菜单选择图片且查看模式为"列表"时显示 或 左侧菜单选择的非图片 -->
      <FileTable
        v-if="(fileType === 1 && showModel === 0) || fileType !== 1"
        :tableData="tableData"
        :loading="loading"
        :fileType="fileType"
        @getTableData="getFileData"
        @handleSelectFile="setOperationFile"
        @handleMoveFile="setMoveFileDialog"
      ></FileTable>
      <!-- 网格模式 v-if 当左侧菜单选择图片且查看模式为"网格"时显示 -->
      <FileGrid
        v-if="fileType === 1 && showModel === 1"
        :tableData="tableData"
        :loading="loading"
      ></FileGrid>
      ...
    </div>
  </div>
</template>

<script>
...
import FileGrid from './components/FileGrid.vue' //  1. 引入网格组件

export default {
  name: 'Home',
  components: {
    ...
    FileGrid //  2.    注册网格组件
  }
}
</script>
```

在 `FileGrid.vue` 中添加以下内容：

```
<template>
  <ul class="file-list" v-loading="loading" element-loading-text="加载中……">
    <li
      class="file-item"
      v-for="(item, index) in tableData"
      :key="index"
      :title="`${item.fileName}.${item.extendName}`"
    >
      <img class="file-img" :src="downloadImgMin(item)" />
      <div class="file-name">{{ item.fileName }}.{{ item.extendName }}</div>
    </li>
  </ul>
</template>

<script>
export default {
  name: "FileGrid",
  props: {
    // 文件数据
    tableData: {
      type: Array,
      required: true,
    },
    // 加载状态
    loading: {
      type: Boolean,
      required: true,
    },
  },
  data() {
    return {};
  },
};
</script>

<style lang="stylus" scoped>
@import '~@/assets/style/mixins.styl';

.file-list {
  height: calc(100vh - 202px);
  display: flex;
  flex-wrap: wrap;
  align-items: flex-start;
  align-content: flex-start;
  list-style: none;
  overflow-y: auto;
  setScrollbar(8px, #EBEEF5, #909399);

  .file-item {
    margin: 16px 16px 0 0;
    border-radius: 4px;
    width: 120px;
    padding: 8px;
    cursor: pointer;
    text-align: center;

    &:hover {
      background: #F5F7FA;
    }

    .file-img {
      width: 100px;
      height: 100px;
    }

    .file-name {
      line-height: 24px;
      font-size: 12px;
      word-break: break-all;
      setEllipsis(2);
    }
  }
}
</style>
```

在 `src/assets/style/mixins.styl` 中添加以下样式：

```stylus
// 文字过长显示省略号
setEllipsis(line)
    display: -webkit-box;
    overflow: hidden;
    white-space: wrap;
    text-overflow: ellipsis;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: line;
```

### 时间线模式



在 `src/views/Home/components` 下新建文件 `FileTimeLine.vue`，内容稍后添加。

在 `index.vue` 中引入此组件，并对现有的文件表格组件和此组件做显隐控制：

```
<template>
  <div class="home">
    <!-- 右侧内容区 -->
    <div class="home-right">
      <!-- 已有代码不再赘述 -->
      ...
      <!-- 网格模式 v-if 当左侧菜单选择图片且查看模式为"网格"时显示 -->
      <FileGrid
        v-if="fileType === 1 && showModel === 1"
        :tableData="tableData"
        :loading="loading"
      ></FileGrid>
      <!-- 时间线模式 v-if 当左侧菜单选择图片且查看模式为"时间线"时显示 -->
      <FileTimeLine
        v-if="fileType === 1 && showModel === 2"
        :tableData="tableData"
        :loading="loading"
      ></FileTimeLine>
      ...
    </div>
  </div>
</template>

<script>
import FileTimeLine from "./components/FileTimeLine.vue"; //  1. 引入时间线模式组件

export default {
  name: "Home",
  components: {
    FileTimeLine, //  2.    注册时间线模式组件
  },
};
</script>
```

在 `FileTimeLine.vue` 中使用 Element UI 的[时间线组件](https://element.eleme.cn/#/zh-CN/component/timeline#ding-yi-shi-jian-chuo)来模仿时间轴：

```
<template>
  <!-- 时间线模式 -->
  <div
    class="image-timeline-wrapper"
    v-loading="loading"
    element-loading-text="加载中……"
  >
    <div class="radio">
      排序：
      <el-radio-group v-model="reverse">
        <el-radio :label="true">倒序</el-radio>
        <el-radio :label="false">正序</el-radio>
      </el-radio-group>
    </div>
    <el-timeline
      class="image-timeline-list"
      :reverse="reverse"
      v-if="imageTimelineData.length"
    >
      <el-timeline-item
        class="image-timeline-item"
        v-for="(item, index) in imageTimelineData"
        :key="index"
        :timestamp="item.uploadDate"
        color="#409EFF"
        placement="top"
      >
        <ul class="image-list">
          <li
            class="image-item"
            v-for="(image, imageIndex) in item.imageList"
            :key="`${index}-${imageIndex}`"
            :title="`${image.fileName}.${image.extendName}`"
          >
            <img class="image" :src="downloadImgMin(image)" />
            <div class="image-name">
              {{ image.fileName }}.{{ image.extendName }}
            </div>
          </li>
        </ul>
      </el-timeline-item>
    </el-timeline>
  </div>
</template>

<script>
export default {
  name: "FileTimeLine",
  props: {
    // 文件数据
    tableData: {
      type: Array,
      required: true,
    },
    // 加载状态
    loading: {
      type: Boolean,
      required: true,
    },
  },
  data() {
    return {
      reverse: true, //  排序规则 - true 倒序 false 正序
    };
  },
  computed: {
    //  按年-月-日分组排序
    imageTimelineData() {
      let res = [];
      //  去重，获取返回的所有日期年-月-日
      let uploadTimeSet = new Set(
        this.tableData.map((item) => item.uploadTime.split(" ")[0])
      );
      let uploadDate = [...uploadTimeSet];
      //  分组
      uploadDate.forEach((element) => {
        res.push({
          uploadDate: element,
          imageList: this.tableData.filter(
            (item) => item.uploadTime.split(" ")[0] === element
          ), //  过滤
        });
      });
      return res;
    },
  },
};
</script>

<style lang="stylus" scoped>
@import '~@/assets/style/mixins.styl';

.image-timeline-wrapper {
  height: calc(100vh - 202px);
  overflow-y: auto;
  setScrollbar(8px);

  .image-timeline-list {
    margin-top: 8px;

    .image-timeline-item {
      .image-list {
        display: flex;
        flex-wrap: wrap;
        align-items: flex-start;
        align-content: flex-start;
        list-style: none;

        .image-item {
          margin: 0 16px 16px 0;
          width: 120px;
          padding: 8px;
          text-align: center;
          cursor: pointer;

          &:hover {
            background: #F5F7FA;
          }

          .image {
            width: 100px;
            height: 100px;
          }

          .image-name {
            margin-top: 8px;
            line-height: 24px;
            font-size: 12px;
            word-break: break-all;
            setEllipsis(2);
          }
        }
      }
    }
  }
}
</style>
```

### 图片在线查看



图片在线查看功能，包括查看、放大、缩小、旋转和上下张切换。在点击图片时，全屏显示大图，通过鼠标滚轮或底部滑块放大缩小图片，可以切换上一张和下一张图片。考虑到列表、网格、时间线模式都需要用到此功能，因此封装为公共组件。

在 `src/components` 下新建文件 `ImgReview.vue`，内容稍后添加，用 Vuex 来共享图片列表数据，在图片点击事件中分发事件，打开图片预览。

### 图片数据共享



在 `src/store/module` 下新建文件 `imgReview.js`，添加以下内容：

```javascript
export default {
  state: {
    imgReviewVisible: false, //  图片查看组件显隐状态
    imgReviewList: [], //  图片列表
    defaultActiveIndex: 0, //  默认当前打开的图片的索引
  },
  mutations: {
    setImgReviewData(state, data) {
      if (data.imgReviewVisible) {
        state.imgReviewVisible = data.imgReviewVisible;
        state.imgReviewList = data.imgReviewList;
        state.defaultActiveIndex = data.activeIndex;
      } else {
        state.imgReviewVisible = data.false;
        state.imgReviewList = [];
        state.defaultActiveIndex = 0;
      }
    },
  },
};
```

在 `src/store/index.js` 中引入此模块：

```javascript
import Vue from "vue";
import Vuex from "vuex";
import imgReview from "./module/imgReview"; // 1. 引入 imgReview 模块

Vue.use(Vuex);

export default new Vuex.Store({
  modules: {
    user,
    file,
    imgReview, // 2. 注册模块
  },
});
```

### 图片在线查看组件添加



在 `src/views/Home/index.vue` 中引入图片在线查看组件：

```
<template>
  <div class="home">
    <!-- 已有代码不再赘述 -->
    <!-- 3. 使用图片在线查看组件 -->
    <ImgReview></ImgReview>
  </div>
</template>

<script>
import ImgReview from "@/components/ImgReview"; //  1. 引入图片在线查看组件

export default {
  name: "Home",
  components: {
    ImgReview, //  2. 注册图片在线查看组件
  },
};
</script>
```

在 `ImgReview.vue` 中添加以下内容：

```
<template>
  <div
    class="img-review-wrapper"
    v-show="imgReviewVisible"
    @click.self="closeImgReview"
    @mousewheel.prevent="rollImg()"
  >
    <!-- 顶部信息栏 & 工具栏 -->
    <div class="tip-wrapper" v-if="imgReviewVisible">
      <div class="name" :title="activeFileName + activeExtendName">
        {{ activeFileName }}.{{ activeExtendName }}
      </div>
      <div class="opera-btn-group">
        <el-input-number
          v-model="inputActiveIndex"
          :min="1"
          :max="imgReviewList.length"
          size="mini"
        ></el-input-number>
        <span class="split-line">/</span>{{ imgReviewList.length }}
      </div>
      <div class="tool-wrapper">
        <i
          class="item el-icon-refresh-right"
          title="向右旋转"
          @click="rotateImg"
        ></i>
        <a
          class="item download-link"
          target="_blank"
          :href="activeDownloadLink"
          :download="activeFileName + '.' + activeExtendName"
        >
          <i class="el-icon-download" title="保存到本地"></i>
        </a>
        <el-tooltip effect="dark" placement="bottom">
          <div slot="content">
            操作提示：<br />
            点击图片以外的区域可退出查看；<br />
            按Esc键可退出查看；<br />
            鼠标滚轮可放大缩小图片
          </div>
          <div class="item text-wrapper">
            <span class="text">操作提示</span>
            <i class="el-icon-question"></i>
          </div>
        </el-tooltip>
      </div>
    </div>
    <!-- 大图查看 -->
    <img
      class="img-large"
      ref="imgLarge"
      v-for="(item, index) in imgReviewList"
      :key="index"
      :src="item.fileUrl"
      v-show="index === activeIndex"
    />
    <!-- 左右切换图标 -->
    <i
      class="pre-icon el-icon-arrow-left"
      title="上一张"
      v-show="activeIndex > 0"
      @click.stop="activeIndex--"
    ></i>
    <i
      class="next-icon el-icon-arrow-right"
      title="下一张"
      v-show="activeIndex < imgReviewList.length - 1"
      @click.stop="activeIndex++"
    ></i>
    <!-- 底部显示放大缩小比例 -->
    <div class="zoom-bar">
      <el-slider
        v-model="imgZoom"
        :min="imgZoomMin"
        :max="imgZoomMax"
        :format-tooltip="formatZoom"
        @input="changeZoom"
      ></el-slider>
      <div class="zoom-count">{{ imgZoom }}%</div>
    </div>
  </div>
</template>

<script>
export default {
  name: "ImgReview",
  data() {
    return {
      rotate: 0, //  旋转角度
      activeIndex: 0, //  当前图片索引 从 0 开始
      imgZoom: 40, //  图片缩放比例
      imgZoomMin: 1, //  图片缩放最小比例
      imgZoomMax: 200, //  图片缩放最大比例
    };
  },
  computed: {
    // 图片查看组件是否显示
    imgReviewVisible() {
      return this.$store.state.imgReview.imgReviewVisible;
    },
    // 图片列表
    imgReviewList() {
      return this.$store.state.imgReview.imgReviewList;
    },
    // 默认显示的图片索引 从 0 开始
    defaultActiveIndex() {
      return this.$store.state.imgReview.defaultActiveIndex;
    },
    // 当前显示的图片名称
    activeFileName() {
      return this.imgReviewList[this.activeIndex].fileName;
    },
    // 当前显示的图片扩展名
    activeExtendName() {
      return this.imgReviewList[this.activeIndex].extendName;
    },
    // 对用户而言 显示的图片索引 从 1 开始 顶部栏输入框控制此值变化
    inputActiveIndex: {
      get() {
        return this.activeIndex + 1;
      },
      set(value) {
        this.activeIndex = value - 1;
      },
    },
    // 当前显示的图片下载链接
    activeDownloadLink() {
      return this.imgReviewList[this.activeIndex].downloadLink;
    },
  },
  watch: {
    // 监听 图片查看组件 显隐状态变化
    imgReviewVisible(val) {
      let body = document.querySelector("body");
      if (val) {
        this.activeIndex = this.defaultActiveIndex;
        // 挂在body下，防止组件元素有样式transform而使position: fixed失效
        body.appendChild(this.$el);
        body.style.overflow = "hidden";
        // 添加键盘Esc事件
        this.$nextTick(() => {
          document.addEventListener("keyup", (e) => {
            if (e.keyCode === 27) {
              this.closeImgReview();
            }
          });
        });
        this.$nextTick(() => {
          this.$refs.imgLarge[this.activeIndex].style.zoom = "40%";
        });
      } else {
        body.style.overflow = "auto";
        document.removeEventListener("keyup", (e) => {
          if (e.keyCode === 27) {
            this.closeImgReview();
          }
        });
      }
    },
    // 监听 图片索引变化
    activeIndex(newValue) {
      this.rotate = 0;
      this.$nextTick(() => {
        if (this.$refs.imgLarge[newValue].style.zoom) {
          this.imgZoom = Number(
            this.$refs.imgLarge[newValue].style.zoom.split("%")[0]
          );
        } else {
          this.$refs.imgLarge[newValue].style.zoom = "40%";
          this.imgZoom = 40;
        }
      });
    },
  },
  methods: {
    //  关闭图片预览
    closeImgReview() {
      this.$store.commit("setImgReviewData", { imgReviewVisible: false });
      this.rotate = 0;
      this.$refs.imgLarge[
        this.activeIndex
      ].style.transform = `rotate(${this.rotate}deg)`;
    },
    // 格式化缩放数字 显示图片缩放比例
    formatZoom(value) {
      return value + "%";
    },
    // 图片缩放改变事件
    changeZoom(value) {
      if (this.$refs.imgLarge) {
        this.$refs.imgLarge[this.activeIndex].style.zoom = value + "%";
      }
    },
    // 缩放图片
    rollImg() {
      let zoom =
        parseInt(this.$refs.imgLarge[this.activeIndex].style.zoom) || 100;
      zoom += event.wheelDelta / 12;
      if (zoom >= this.imgZoomMin && zoom < this.imgZoomMax) {
        this.imgZoom = zoom;
        this.$refs.imgLarge[this.activeIndex].style.zoom = zoom + "%";
      }
      return false;
    },
    //  旋转图片
    rotateImg() {
      this.rotate += 90;
      this.$refs.imgLarge[
        this.activeIndex
      ].style.transform = `rotate(${this.rotate}deg)`;
    },
  },
};
</script>

<style lang="stylus" scoped>
@import '~@/assets/style/mixins.styl';

.img-review-wrapper {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  overflow: auto;
  width: 100%;
  height: 100%;
  z-index: 2010;
  text-align: center;
  display: flex;
  align-items: center;
  animation: imgReviewAnimation 0.3s;
  -webkit-animation: imgReviewAnimation 0.3s; /* Safari and Chrome */
  animation-iteration-count: 0.3;
  -webkit-animation-iteration-count: 0.3;
  animation-fill-mode: forwards;
  -webkit-animation-fill-mode: forwards; /* Safari 和 Chrome */

  @keyframes imgReviewAnimation {
    0% {
      background: transparent;
    }

    100% {
      background: rgba(0, 0, 0, 0.8);
    }
  }

  @keyframes imgReviewAnimation {
    0% {
      background: transparent;
    }

    100% {
      background: rgba(0, 0, 0, 0.8);
    }
  }

  .tip-wrapper {
    box-sizing: border-box;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 2011;
    background: rgba(0, 0, 0, 0.5);
    padding: 0 48px;
    width: 100%;
    height: 48px;
    line-height: 48px;
    color: #fff;
    font-size: 16px;
    display: flex;
    justify-content: space-between;

    .name {
      flex: 1;
      padding-right: 16px;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .opera-btn-group {
      width: 100px;
      display: flex;

      >>> .el-input-number {
        width: 40px;

        .el-input-number__decrease, .el-input-number__increase {
          display: none;
        }

        .el-input__inner {
          margin-top: 14px;
          background: rgba(0, 0, 0, 0.5);
          height: 20px;
          line-height: 20px;
          padding: 0;
          font-size: 16px;
          color: #fff;
        }
      }

      .split-line {
        margin: 0 8px;
      }
    }

    .tool-wrapper {
      flex: 1;
      display: flex;
      justify-content: flex-end;

      .item {
        margin-left: 16px;
        cursor: pointer;

        &:hover {
          opacity: 0.7;
        }
      }

      .el-icon-refresh-right {
        line-height: 48px;
        font-size: 18px;
      }

      .download-link {
        color: inherit;
        font-size: 18px;
      }

      .text-wrapper {
        margin-left: 32px;

        .text {
          margin-right: 8px;
        }
      }
    }
  }

  .img-large {
    margin: 0 auto;
    transition: transform 0.5s;
    -webkit-transition: transform 0.5s; /* Safari */
  }

  .pre-icon, .next-icon {
    font-size: 60px;
    color: #fff;
    position: fixed;
    top: 50%;
    cursor: pointer;

    &:hover {
      opacity: 0.7;
    }
  }

  .pre-icon {
    left: 64px;
  }

  .next-icon {
    right: 64px;
  }

  .zoom-bar {
    position: fixed;
    right: 0;
    bottom: 20px;
    left: 0;
    margin: 0 auto;
    width: 600px;
    display: flex;

    >>> .el-slider {
      flex: 1;

      .el-slider__bar {
        background: $PrimaryText;
      }

      .el-slider__button {
        border-color: $PrimaryText;
      }
    }

    .zoom-count {
      width: 60px;
      height: 38px;
      line-height: 38px;
      text-align: right;
      color: #fff;
    }
  }
}
</style>
```

### 图片在线查看事件添加



当左侧菜单选择图片时，右侧显示图片列表，在图片点击事件中触发图片在线查看。

在 `FileGrid.vue` 中添加图片点击事件 `handleFileClick()`：

```
<template>
  <ul class="file-list" v-loading="loading" element-loading-text="加载中……">
    <li
      class="file-item"
      v-for="(item, index) in tableData"
      :key="index"
      :title="`${item.fileName}.${item.extendName}`"
      @click="handleFileClick(index, tableData)"
    >
      <img class="file-img" :src="downloadImgMin(item)" />
      <div class="file-name">{{ item.fileName }}.{{ item.extendName }}</div>
    </li>
  </ul>
</template>

<script>
export default {
  name: 'FileGrid',
  ...
  methods: {
    //  文件点击事件
    handleFileClick(activeIndex, imgList) {
      //  图片分类下 - 大图查看
      let data = {
        imgReviewVisible: true,
        imgReviewList: imgList.map((item) => {
          return {
            fileUrl: `/api${item.fileUrl}`,
            downloadLink: `/api/filetransfer/downloadfile?userFileId=${item.userFileId}`,
            fileName: item.fileName,
            extendName: item.extendName
          }
        }),
        activeIndex: activeIndex
      }
      this.$store.commit('setImgReviewData', data) //    触发图片在线查看
    }
  }
}
</script>
```

在 `FileTimeLine.vue` 中添加图片点击事件 `handleFileClick()`：

```
<li
  class="image-item"
  v-for="(image, imageIndex) in item.imageList"
  :key="`${index}-${imageIndex}`"
  :title="`${image.fileName}.${image.extendName}`"
  @click="handleFileClick(imageIndex, item.imageList)"
>
    <img class="image" :src="downloadImgMin(image)" />
    <div class="image-name">
        {{ image.fileName }}.{{ image.extendName }}
    </div>
</li>
<script>
export default {
  name: 'FileTimeLine',
  ...
  methods: {
    // 文件点击事件
    handleFileClick(activeIndex, imgList) {
      let data = {
        imgReviewVisible: true,
        imgReviewList: imgList.map((item) => {
          return {
            fileUrl: `/api${item.fileUrl}`,
            downloadLink: `/api/filetransfer/downloadfile?userFileId=${item.userFileId}`,
            fileName: item.fileName,
            extendName: item.extendName
          }
        }),
        activeIndex: activeIndex
      }
      this.$store.commit('setImgReviewData', data) //    触发图片在线查看
    }
  }
}
</script>
```

在 `FileTable.vue` 中，对表格当前行是图片类型的文件，在原有的文件名点击事件 `handleFileNameClick` 中触发图片在线查看：

```vue
// 文件名点击事件
handleFileNameClick(row) {
    //  若是目录则进入目录
    if (row.isDir) {
        this.$router.push({
            query: {
                filePath: `${row.filePath}${row.fileName}/`,
                fileType: 0
            }
        })
    } else {
        //  若当前点击项是图片
        const PIC = ['png', 'jpg', 'jpeg', 'gif', 'svg']
        if (PIC.includes(row.extendName)) {
            let data = {
                imgReviewVisible: true,
                imgReviewList: [{
                    fileUrl: `/api${row.fileUrl}`,
                    downloadLink: `/api/filetransfer/downloadfile?userFileId=${row.userFileId}`,
                    fileName: row.fileName,
                    extendName: row.extendName
                }],
                activeIndex: 0
            }
            this.$store.commit('setImgReviewData', data)    //    触发图片在线查看
        }
    }
}
```